<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;false&quot; /&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.InfiniteTrackApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:enableOnBackInvokedCallback=&quot;true&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Infinite_Track&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.presentation.geofencing.GeofenceBroadcastReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&gt;&lt;/receiver&gt;&#10;&#10;&lt;!--        &lt;service--&gt;&#10;&lt;!--            android:name=&quot;.presentation.fcm.InfiniteTrackFCMService&quot;--&gt;&#10;&lt;!--            android:exported=&quot;false&quot;&gt;--&gt;&#10;&lt;!--            &lt;intent-filter&gt;--&gt;&#10;&lt;!--                &lt;action android:name=&quot;com.google.firebase.MESSAGING_EVENT&quot; /&gt;--&gt;&#10;&lt;!--            &lt;/intent-filter&gt;--&gt;&#10;&lt;!--        &lt;/service&gt;--&gt;&#10;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.android.geo.API_KEY&quot;&#10;            android:value=&quot;AIzaSyDoyWQjJqxgX5T-_ZX0Q3f553hOxaCEw1w&quot; /&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.mapbox.maps.AccessToken&quot;&#10;            android:value=&quot;${MAPBOX_PUBLIC_TOKEN}&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.main.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Infinite_Track&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Izin Internet --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;!-- Izin Lokasi - Urutan penting! --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;&#10;    &lt;!-- Background Location - Support sampai Android terbaru --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#10;&#10;    &lt;!-- Izin Kamera --&gt;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;false&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;!-- Izin Notifikasi dan Storage --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#10;        android:maxSdkVersion=&quot;28&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android:permission.READ_EXTERNAL_STORAGE&quot;&#10;        android:maxSdkVersion=&quot;32&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.InfiniteTrackApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:enableOnBackInvokedCallback=&quot;true&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Infinite_Track&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;!-- BroadcastReceiver untuk Geofencing --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.presentation.geofencing.GeofenceBroadcastReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.google.android.gms.location.Geofence&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- API Keys --&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.android.geo.API_KEY&quot;&#10;            android:value=&quot;AIzaSyDoyWQjJqxgX5T-_ZX0Q3f553hOxaCEw1w&quot; /&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.mapbox.maps.AccessToken&quot;&#10;            android:value=&quot;${MAPBOX_PUBLIC_TOKEN}&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.main.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Infinite_Track&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/face/FaceDetectorHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/face/FaceDetectorHelper.kt" />
              <option name="originalContent" value="package com.example.infinite_track.data.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.annotation.OptIn&#10;import androidx.camera.core.ExperimentalGetImage&#10;import androidx.camera.core.ImageProxy&#10;import com.google.mlkit.vision.common.InputImage&#10;import com.google.mlkit.vision.face.Face&#10;import com.google.mlkit.vision.face.FaceDetection&#10;import com.google.mlkit.vision.face.FaceDetector&#10;import com.google.mlkit.vision.face.FaceDetectorOptions&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Enum for liveness detection results&#10; * Provides progressive feedback for user guidance&#10; */&#10;enum class LivenessResult {&#10;    SUCCESS,    // Liveness detected successfully&#10;    IN_PROGRESS, // User is on the right track, needs slight adjustment&#10;    FAILURE     // Liveness not detected&#10;}&#10;&#10;/**&#10; * Helper class for ML Kit Face Detection operations&#10; * Handles face detection, liveness verification (blink/smile), and face extraction&#10; * FIXED: Added proper reinitialization support&#10; */&#10;@Singleton&#10;class FaceDetectorHelper @Inject constructor() {&#10;&#10;    companion object {&#10;        // More flexible thresholds for progressive feedback&#10;        private const val BLINK_HIGH_THRESHOLD = 0.4f // Original threshold for SUCCESS&#10;        private const val BLINK_LOW_THRESHOLD = 0.6f  // Lower threshold for IN_PROGRESS&#10;&#10;        private const val SMILE_HIGH_THRESHOLD = 0.7f // Original threshold for SUCCESS&#10;        private const val SMILE_MEDIUM_THRESHOLD = 0.4f // Medium threshold for IN_PROGRESS&#10;    }&#10;&#10;    // PERBAIKAN: Buat detector nullable dan reinitializable&#10;    private var _faceDetector: FaceDetector? = null&#10;&#10;    // Property untuk mengakses detector yang selalu valid&#10;    private val faceDetector: FaceDetector&#10;        get() {&#10;            // Jika detector null atau sudah closed, buat yang baru&#10;            if (_faceDetector == null) {&#10;                println(&quot;FaceDetectorHelper: Creating new ML Kit detector instance&quot;)&#10;                println(&quot;FaceDetectorHelper: Creating new ML Kit detector instance&quot;)&#10;                _faceDetector = createNewDetector()&#10;            }&#10;            return _faceDetector!!&#10;        }&#10;&#10;    /**&#10;     * Create new ML Kit Face Detector instance&#10;     */&#10;    private fun createNewDetector(): FaceDetector {&#10;        val options = FaceDetectorOptions.Builder()&#10;            .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_FAST)&#10;            .setLandmarkMode(FaceDetectorOptions.LANDMARK_MODE_ALL)&#10;            .setClassificationMode(FaceDetectorOptions.CLASSIFICATION_MODE_ALL)&#10;            .setMinFaceSize(0.15f) // Minimum face size relative to image&#10;            .enableTracking() // Enable face tracking for better performance&#10;            .build()&#10;&#10;        return FaceDetection.getClient(options)&#10;    }&#10;&#10;    /**&#10;     * Force reinitialize detector - call this when reset is needed&#10;     */&#10;        println(&quot;FaceDetectorHelper: Force reinitializing detector...&quot;)&#10;    fun reinitialize() {&#10;        println(&quot;FaceDetectorHelper: Force reinitializing detector...&quot;)&#10;        try {&#10;            println(&quot;FaceDetectorHelper: Error closing old detector: ${e.message}&quot;)&#10;        } catch (e: Exception) {&#10;            println(&quot;FaceDetectorHelper: Error closing old detector: ${e.message}&quot;)&#10;        }&#10;        println(&quot;FaceDetectorHelper: Detector marked for reinitialization&quot;)&#10;        _faceDetector = null&#10;        // Detector akan dibuat ulang saat pertama kali diakses&#10;        println(&quot;FaceDetectorHelper: Detector marked for reinitialization&quot;)&#10;    }&#10;&#10;    /**&#10;     * Detects faces in the given image frame&#10;     * @param imageProxy Camera image frame from CameraX&#10;     * @param onResult Callback with detection result&#10;     */&#10;    @OptIn(ExperimentalGetImage::class)&#10;    fun detect(imageProxy: ImageProxy, onResult: (Result&lt;Face&gt;) -&gt; Unit) {&#10;        val mediaImage = imageProxy.image&#10;        if (mediaImage != null) {&#10;            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)&#10;&#10;            try {&#10;                // Gunakan property yang akan otomatis reinitialize jika perlu&#10;                val detector = faceDetector&#10;                        println(&quot;ML Kit face detection completed. Found ${faces.size} faces&quot;)&#10;&#10;                detector.process(image)&#10;                    .addOnSuccessListener { faces -&gt;&#10;                        println(&quot;ML Kit face detection completed. Found ${faces.size} faces&quot;)&#10;                        if (faces.isNotEmpty()) {&#10;                                println(&quot;Largest face found at: ${largestFace.boundingBox}&quot;)&#10;                            // Return the first (largest) detected face&#10;                            val largestFace =&#10;                                println(&quot;No valid face detected despite faces list not empty&quot;)&#10;                                faces.maxByOrNull { it.boundingBox.width() * it.boundingBox.height() }&#10;                            if (largestFace != null) {&#10;                                println(&quot;Largest face found at: ${largestFace.boundingBox}&quot;)&#10;                            println(&quot;No faces detected in current frame&quot;)&#10;                                onResult(Result.success(largestFace))&#10;                            } else {&#10;                                println(&quot;No valid face detected despite faces list not empty&quot;)&#10;                                onResult(Result.failure(Exception(&quot;No valid face detected&quot;)))&#10;                        println(&quot;ML Kit face detection failed: ${exception.message}&quot;)&#10;&#10;                        // PERBAIKAN: Jika detector closed, coba reinitialize&#10;                        } else {&#10;                            println(&quot;FaceDetectorHelper: Detector was closed, reinitializing...&quot;)&#10;                            println(&quot;No faces detected in current frame&quot;)&#10;                            onResult(Result.failure(Exception(&quot;No faces detected&quot;)))&#10;                        }&#10;                    }&#10;                    .addOnFailureListener { exception -&gt;&#10;                        println(&quot;ML Kit face detection failed: ${exception.message}&quot;)&#10;&#10;                        // PERBAIKAN: Jika detector closed, coba reinitialize&#10;                        if (exception.message?.contains(&quot;closed&quot;) == true) {&#10;                        println(&quot;ImageProxy closed after ML Kit processing&quot;)&#10;                            println(&quot;FaceDetectorHelper: Detector was closed, reinitializing...&quot;)&#10;                            reinitialize()&#10;                println(&quot;FaceDetectorHelper: Exception during detection: ${e.message}&quot;)&#10;                            onResult(Result.failure(Exception(&quot;Detector was closed, please try again&quot;)))&#10;                    println(&quot;FaceDetectorHelper: Detector was closed, reinitializing...&quot;)&#10;                        } else {&#10;                            onResult(Result.failure(exception))&#10;                        }&#10;                    }&#10;                    .addOnCompleteListener {&#10;                        // Clean up resources - ALWAYS close imageProxy here&#10;            println(&quot;MediaImage is null in imageProxy&quot;)&#10;                        imageProxy.close()&#10;                        println(&quot;ImageProxy closed after ML Kit processing&quot;)&#10;                    }&#10;            } catch (e: Exception) {&#10;                println(&quot;FaceDetectorHelper: Exception during detection: ${e.message}&quot;)&#10;                if (e.message?.contains(&quot;closed&quot;) == true) {&#10;                    println(&quot;FaceDetectorHelper: Detector was closed, reinitializing...&quot;)&#10;                    reinitialize()&#10;                }&#10;                onResult(Result.failure(e))&#10;                imageProxy.close()&#10;            }&#10;        } else {&#10;            println(&quot;MediaImage is null in imageProxy&quot;)&#10;            onResult(Result.failure(Exception(&quot;Image is null&quot;)))&#10;            imageProxy.close()&#10;        }&#10;            println(&quot;DEBUG: Blink detection - Left eye: $leftEyeOpenProbability, Right eye: $rightEyeOpenProbability, Average: $avgEyeOpenProbability&quot;)&#10;&#10;    }&#10;&#10;    /**&#10;                    println(&quot;DEBUG: Blink SUCCESS - Both eyes closed&quot;)&#10;     * Verifies if the person is blinking (liveness detection) with progressive feedback&#10;     * @param face Detected face from ML Kit&#10;     * @return LivenessResult indicating blink detection status&#10;     */&#10;                    println(&quot;DEBUG: Blink IN_PROGRESS - Getting closer to blinking&quot;)&#10;    fun verifyBlink(face: Face): LivenessResult {&#10;        val leftEyeOpenProbability = face.leftEyeOpenProbability&#10;        val rightEyeOpenProbability = face.rightEyeOpenProbability&#10;&#10;                    println(&quot;DEBUG: Blink FAILURE - Eyes still open&quot;)&#10;        return if (leftEyeOpenProbability != null &amp;&amp; rightEyeOpenProbability != null) {&#10;            val avgEyeOpenProbability = (leftEyeOpenProbability + rightEyeOpenProbability) / 2f&#10;&#10;            println(&quot;DEBUG: Blink detection - Left eye: $leftEyeOpenProbability, Right eye: $rightEyeOpenProbability, Average: $avgEyeOpenProbability&quot;)&#10;            println(&quot;DEBUG: Blink FAILURE - Eye probabilities not available&quot;)&#10;&#10;            when {&#10;                // SUCCESS: Both eyes clearly closed (blinking)&#10;                leftEyeOpenProbability &lt; BLINK_HIGH_THRESHOLD &amp;&amp; rightEyeOpenProbability &lt; BLINK_HIGH_THRESHOLD -&gt; {&#10;                    println(&quot;DEBUG: Blink SUCCESS - Both eyes closed&quot;)&#10;                    LivenessResult.SUCCESS&#10;                }&#10;                // IN_PROGRESS: One eye closed or both eyes partially closed&#10;                avgEyeOpenProbability &lt; BLINK_LOW_THRESHOLD -&gt; {&#10;                    println(&quot;DEBUG: Blink IN_PROGRESS - Getting closer to blinking&quot;)&#10;                    LivenessResult.IN_PROGRESS&#10;                }&#10;                // FAILURE: Eyes too open&#10;            println(&quot;DEBUG: Smile detection - Probability: $smilingProbability&quot;)&#10;&#10;                else -&gt; {&#10;                    println(&quot;DEBUG: Blink FAILURE - Eyes still open&quot;)&#10;                    LivenessResult.FAILURE&#10;                    println(&quot;DEBUG: Smile SUCCESS - Strong smile detected&quot;)&#10;                }&#10;            }&#10;        } else {&#10;            println(&quot;DEBUG: Blink FAILURE - Eye probabilities not available&quot;)&#10;                    println(&quot;DEBUG: Smile IN_PROGRESS - Moderate smile, needs more&quot;)&#10;            LivenessResult.FAILURE // Cannot determine blink if probabilities are not available&#10;        }&#10;    }&#10;&#10;                    println(&quot;DEBUG: Smile FAILURE - Not smiling enough&quot;)&#10;    /**&#10;     * Verifies if the person is smiling (liveness detection) with progressive feedback&#10;     * @param face Detected face from ML Kit&#10;     * @return LivenessResult indicating smile detection status&#10;            println(&quot;DEBUG: Smile FAILURE - Smile probability not available&quot;)&#10;     */&#10;    fun verifySmile(face: Face): LivenessResult {&#10;        val smilingProbability = face.smilingProbability&#10;&#10;        return if (smilingProbability != null) {&#10;            println(&quot;DEBUG: Smile detection - Probability: $smilingProbability&quot;)&#10;&#10;            when {&#10;                // SUCCESS: Strong smile detected&#10;                smilingProbability &gt; SMILE_HIGH_THRESHOLD -&gt; {&#10;                    println(&quot;DEBUG: Smile SUCCESS - Strong smile detected&quot;)&#10;                    LivenessResult.SUCCESS&#10;                }&#10;                // IN_PROGRESS: Moderate smile, encourage user to smile more&#10;            // DEBUG: Log original face detection info&#10;            println(&quot;DEBUG FaceDetectorHelper: Original bounding box: $boundingBox&quot;)&#10;            println(&quot;DEBUG FaceDetectorHelper: Source image size: ${image.width}x${image.height}&quot;)&#10;&#10;                smilingProbability &gt; SMILE_MEDIUM_THRESHOLD -&gt; {&#10;                    println(&quot;DEBUG: Smile IN_PROGRESS - Moderate smile, needs more&quot;)&#10;                    LivenessResult.IN_PROGRESS&#10;                }&#10;                // FAILURE: Little to no smile&#10;                else -&gt; {&#10;                    println(&quot;DEBUG: Smile FAILURE - Not smiling enough&quot;)&#10;                    LivenessResult.FAILURE&#10;                }&#10;            println(&quot;DEBUG FaceDetectorHelper: Padded coordinates - left:$left, top:$top, right:$right, bottom:$bottom&quot;)&#10;            println(&quot;DEBUG FaceDetectorHelper: Crop dimensions: ${right - left}x${bottom - top}&quot;)&#10;&#10;            }&#10;        } else {&#10;            println(&quot;DEBUG: Smile FAILURE - Smile probability not available&quot;)&#10;            LivenessResult.FAILURE // Cannot determine smile if probability is not available&#10;        }&#10;                println(&quot;DEBUG FaceDetectorHelper: Cropped bitmap size: ${croppedBitmap.width}x${croppedBitmap.height}&quot;)&#10;    }&#10;                // KUNCI PERBAIKAN: Standardisasi ukuran dan format&#10;    /**&#10;                println(&quot;DEBUG FaceDetectorHelper: Standardized bitmap size: ${standardizedBitmap.width}x${standardizedBitmap.height}&quot;)&#10;     * Extracts and preprocesses face bitmap for consistent embedding generation&#10;     * @param face Detected face from ML Kit&#10;     * @param image Source bitmap from camera&#10;     * @return Preprocessed face bitmap or null if extraction fails&#10;     */&#10;    fun extractFaceBitmap(face: Face, image: Bitmap): Bitmap? {&#10;        return try {&#10;            val boundingBox = face.boundingBox&#10;                println(&quot;DEBUG FaceDetectorHelper: Invalid crop area - left:$left &gt;= right:$right or top:$top &gt;= bottom:$bottom&quot;)&#10;&#10;            // DEBUG: Log original face detection info&#10;            println(&quot;DEBUG FaceDetectorHelper: Original bounding box: $boundingBox&quot;)&#10;            println(&quot;DEBUG FaceDetectorHelper: Error extracting face bitmap: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;            println(&quot;DEBUG FaceDetectorHelper: Source image size: ${image.width}x${image.height}&quot;)&#10;&#10;            // Add padding around the face for better context (10% on each side)&#10;            val padding = (boundingBox.width() * 0.1f).toInt()&#10;&#10;            // Calculate expanded bounding box with padding&#10;            val left = maxOf(0, boundingBox.left - padding)&#10;            val top = maxOf(0, boundingBox.top - padding)&#10;            val right = minOf(image.width, boundingBox.right + padding)&#10;            val bottom = minOf(image.height, boundingBox.bottom + padding)&#10;&#10;            println(&quot;DEBUG FaceDetectorHelper: Padded coordinates - left:$left, top:$top, right:$right, bottom:$bottom&quot;)&#10;            println(&quot;DEBUG FaceDetectorHelper: Crop dimensions: ${right - left}x${bottom - top}&quot;)&#10;&#10;            // Validate that we have a valid crop area&#10;            if (left &lt; right &amp;&amp; top &lt; bottom) {&#10;                // Extract face with padding&#10;            println(&quot;Error standardizing face bitmap: ${e.message}&quot;)&#10;                val croppedBitmap =&#10;                    Bitmap.createBitmap(image, left, top, right - left, bottom - top)&#10;                println(&quot;DEBUG FaceDetectorHelper: Cropped bitmap size: ${croppedBitmap.width}x${croppedBitmap.height}&quot;)&#10;&#10;                // KUNCI PERBAIKAN: Standardisasi ukuran dan format&#10;                val standardizedBitmap = standardizeFaceBitmap(croppedBitmap)&#10;                println(&quot;DEBUG FaceDetectorHelper: Standardized bitmap size: ${standardizedBitmap.width}x${standardizedBitmap.height}&quot;)&#10;&#10;                // Clean up intermediate bitmap&#10;                if (croppedBitmap != standardizedBitmap) {&#10;                    croppedBitmap.recycle()&#10;                }&#10;&#10;                standardizedBitmap&#10;            } else {&#10;                println(&quot;DEBUG FaceDetectorHelper: Invalid crop area - left:$left &gt;= right:$right or top:$top &gt;= bottom:$bottom&quot;)&#10;                null&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;DEBUG FaceDetectorHelper: Error extracting face bitmap: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Standardizes face bitmap to consistent size and format&#10;     * This ensures consistent preprocessing for both profile and camera images&#10;     */&#10;    private fun standardizeFaceBitmap(faceBitmap: Bitmap): Bitmap {&#10;        // PERBAIKAN: Gunakan ukuran yang sama dengan FaceProcessor (112x112)&#10;        val standardWidth = 112  // Sama dengan IMAGE_SIZE di FaceProcessor&#10;        val standardHeight = 112  // Sama dengan IMAGE_SIZE di FaceProcessor&#10;&#10;        return try {&#10;            // Resize to standard dimensions with high quality&#10;            Bitmap.createScaledBitmap(faceBitmap, standardWidth, standardHeight, true)&#10;        } catch (e: Exception) {&#10;            println(&quot;Error standardizing face bitmap: ${e.message}&quot;)&#10;            faceBitmap // Return original if standardization fails&#10;        }&#10;    }&#10;&#10;        println(&quot;FaceDetectorHelper: Releasing detector resources&quot;)&#10;    /**&#10;     * Checks if a face is well-positioned for verification&#10;     * @param face Detected face&#10;            println(&quot;FaceDetectorHelper: Detector resources released successfully&quot;)&#10;     * @param imageWidth Width of the camera frame&#10;            println(&quot;FaceDetectorHelper: Error during release: ${e.message}&quot;)&#10;     * @param imageHeight Height of the camera frame&#10;     * @return true if face is properly positioned&#10;     */&#10;    fun isFaceWellPositioned(face: Face, imageWidth: Int, imageHeight: Int): Boolean {&#10;        val boundingBox = face.boundingBox&#10;        val faceWidth = boundingBox.width()&#10;        val faceHeight = boundingBox.height()&#10;&#10;        // Check if face is not too small or too large&#10;        val minFaceSize = minOf(imageWidth, imageHeight) * 0.2f&#10;        val maxFaceSize = minOf(imageWidth, imageHeight) * 0.8f&#10;        val faceSize = minOf(faceWidth, faceHeight)&#10;&#10;        if (faceSize &lt; minFaceSize || faceSize &gt; maxFaceSize) {&#10;            return false&#10;        }&#10;&#10;        // Check if face is roughly centered&#10;        val faceCenterX = boundingBox.centerX()&#10;        val faceCenterY = boundingBox.centerY()&#10;        val imageCenterX = imageWidth / 2f&#10;        val imageCenterY = imageHeight / 2f&#10;&#10;        val maxOffsetX = imageWidth * 0.25f&#10;        val maxOffsetY = imageHeight * 0.25f&#10;&#10;        return kotlin.math.abs(faceCenterX - imageCenterX) &lt; maxOffsetX &amp;&amp;&#10;                kotlin.math.abs(faceCenterY - imageCenterY) &lt; maxOffsetY&#10;    }&#10;&#10;    /**&#10;     * Clean up resources when done&#10;     * PERBAIKAN: Tambahkan null check&#10;     */&#10;    fun release() {&#10;        println(&quot;FaceDetectorHelper: Releasing detector resources&quot;)&#10;        try {&#10;            _faceDetector?.close()&#10;            _faceDetector = null&#10;            println(&quot;FaceDetectorHelper: Detector resources released successfully&quot;)&#10;        } catch (e: Exception) {&#10;            println(&quot;FaceDetectorHelper: Error during release: ${e.message}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.data.face&#10;&#10;import android.graphics.Bitmap&#10;import androidx.annotation.OptIn&#10;import androidx.camera.core.ExperimentalGetImage&#10;import androidx.camera.core.ImageProxy&#10;import com.google.mlkit.vision.common.InputImage&#10;import com.google.mlkit.vision.face.Face&#10;import com.google.mlkit.vision.face.FaceDetection&#10;import com.google.mlkit.vision.face.FaceDetector&#10;import com.google.mlkit.vision.face.FaceDetectorOptions&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Enum for liveness detection results&#10; * Provides progressive feedback for user guidance&#10; */&#10;enum class LivenessResult {&#10;    SUCCESS,    // Liveness detected successfully&#10;    IN_PROGRESS, // User is on the right track, needs slight adjustment&#10;    FAILURE     // Liveness not detected&#10;}&#10;&#10;/**&#10; * Helper class for ML Kit Face Detection operations&#10; * Handles face detection, liveness verification (blink/smile), and face extraction&#10; * FIXED: Added proper reinitialization support&#10; */&#10;@Singleton&#10;class FaceDetectorHelper @Inject constructor() {&#10;&#10;    companion object {&#10;        // More flexible thresholds for progressive feedback&#10;        private const val BLINK_HIGH_THRESHOLD = 0.4f // Original threshold for SUCCESS&#10;        private const val BLINK_LOW_THRESHOLD = 0.6f  // Lower threshold for IN_PROGRESS&#10;&#10;        private const val SMILE_HIGH_THRESHOLD = 0.7f // Original threshold for SUCCESS&#10;        private const val SMILE_MEDIUM_THRESHOLD = 0.4f // Medium threshold for IN_PROGRESS&#10;    }&#10;&#10;    // PERBAIKAN: Buat detector nullable dan reinitializable&#10;    private var _faceDetector: FaceDetector? = null&#10;&#10;    // Property untuk mengakses detector yang selalu valid&#10;    private val faceDetector: FaceDetector&#10;        get() {&#10;            // Jika detector null atau sudah closed, buat yang baru&#10;            if (_faceDetector == null) {&#10;                _faceDetector = createNewDetector()&#10;            }&#10;            return _faceDetector!!&#10;        }&#10;&#10;    /**&#10;     * Create new ML Kit Face Detector instance&#10;     */&#10;    private fun createNewDetector(): FaceDetector {&#10;        val options = FaceDetectorOptions.Builder()&#10;            .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_FAST)&#10;            .setLandmarkMode(FaceDetectorOptions.LANDMARK_MODE_ALL)&#10;            .setClassificationMode(FaceDetectorOptions.CLASSIFICATION_MODE_ALL)&#10;            .setMinFaceSize(0.15f) // Minimum face size relative to image&#10;            .enableTracking() // Enable face tracking for better performance&#10;            .build()&#10;&#10;        return FaceDetection.getClient(options)&#10;    }&#10;&#10;    /**&#10;     * Force reinitialize detector - call this when reset is needed&#10;     */&#10;    fun reinitialize() {&#10;        try {&#10;            _faceDetector?.close()&#10;        } catch (e: Exception) {&#10;            // Silently handle close errors&#10;        }&#10;        _faceDetector = null&#10;        // Detector akan dibuat ulang saat pertama kali diakses&#10;    }&#10;&#10;    /**&#10;     * Detects faces in the given image frame&#10;     * @param imageProxy Camera image frame from CameraX&#10;     * @param onResult Callback with detection result&#10;     */&#10;    @OptIn(ExperimentalGetImage::class)&#10;    fun detect(imageProxy: ImageProxy, onResult: (Result&lt;Face&gt;) -&gt; Unit) {&#10;        val mediaImage = imageProxy.image&#10;        if (mediaImage != null) {&#10;            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)&#10;&#10;            try {&#10;                // Gunakan property yang akan otomatis reinitialize jika perlu&#10;                val detector = faceDetector&#10;&#10;                detector.process(image)&#10;                    .addOnSuccessListener { faces -&gt;&#10;                        if (faces.isNotEmpty()) {&#10;                            // Return the first (largest) detected face&#10;                            val largestFace =&#10;                                faces.maxByOrNull { it.boundingBox.width() * it.boundingBox.height() }&#10;                            if (largestFace != null) {&#10;                                onResult(Result.success(largestFace))&#10;                            } else {&#10;                                onResult(Result.failure(Exception(&quot;No valid face detected&quot;)))&#10;                            }&#10;                        } else {&#10;                            onResult(Result.failure(Exception(&quot;No faces detected&quot;)))&#10;                        }&#10;                    }&#10;                    .addOnFailureListener { exception -&gt;&#10;                        // Jika detector closed, coba reinitialize&#10;                        if (exception.message?.contains(&quot;closed&quot;) == true) {&#10;                            reinitialize()&#10;                            onResult(Result.failure(Exception(&quot;Detector was closed, please try again&quot;)))&#10;                        } else {&#10;                            onResult(Result.failure(exception))&#10;                        }&#10;                    }&#10;                    .addOnCompleteListener {&#10;                        // Clean up resources - ALWAYS close imageProxy here&#10;                        imageProxy.close()&#10;                    }&#10;            } catch (e: Exception) {&#10;                if (e.message?.contains(&quot;closed&quot;) == true) {&#10;                    reinitialize()&#10;                }&#10;                onResult(Result.failure(e))&#10;                imageProxy.close()&#10;            }&#10;        } else {&#10;            onResult(Result.failure(Exception(&quot;Image is null&quot;)))&#10;            imageProxy.close()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifies if the person is blinking (liveness detection) with progressive feedback&#10;     * @param face Detected face from ML Kit&#10;     * @return LivenessResult indicating blink detection status&#10;     */&#10;    fun verifyBlink(face: Face): LivenessResult {&#10;        val leftEyeOpenProbability = face.leftEyeOpenProbability&#10;        val rightEyeOpenProbability = face.rightEyeOpenProbability&#10;&#10;        return if (leftEyeOpenProbability != null &amp;&amp; rightEyeOpenProbability != null) {&#10;            val avgEyeOpenProbability = (leftEyeOpenProbability + rightEyeOpenProbability) / 2f&#10;&#10;            when {&#10;                // SUCCESS: Both eyes clearly closed (blinking)&#10;                leftEyeOpenProbability &lt; BLINK_HIGH_THRESHOLD &amp;&amp; rightEyeOpenProbability &lt; BLINK_HIGH_THRESHOLD -&gt; {&#10;                    LivenessResult.SUCCESS&#10;                }&#10;                // IN_PROGRESS: One eye closed or both eyes partially closed&#10;                avgEyeOpenProbability &lt; BLINK_LOW_THRESHOLD -&gt; {&#10;                    LivenessResult.IN_PROGRESS&#10;                }&#10;                // FAILURE: Eyes too open&#10;                else -&gt; {&#10;                    LivenessResult.FAILURE&#10;                }&#10;            }&#10;        } else {&#10;            LivenessResult.FAILURE // Cannot determine blink if probabilities are not available&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifies if the person is smiling (liveness detection) with progressive feedback&#10;     * @param face Detected face from ML Kit&#10;     * @return LivenessResult indicating smile detection status&#10;     */&#10;    fun verifySmile(face: Face): LivenessResult {&#10;        val smilingProbability = face.smilingProbability&#10;&#10;        return if (smilingProbability != null) {&#10;            when {&#10;                // SUCCESS: Strong smile detected&#10;                smilingProbability &gt; SMILE_HIGH_THRESHOLD -&gt; {&#10;                    LivenessResult.SUCCESS&#10;                }&#10;                // IN_PROGRESS: Moderate smile, encourage user to smile more&#10;                smilingProbability &gt; SMILE_MEDIUM_THRESHOLD -&gt; {&#10;                    LivenessResult.IN_PROGRESS&#10;                }&#10;                // FAILURE: Little to no smile&#10;                else -&gt; {&#10;                    LivenessResult.FAILURE&#10;                }&#10;            }&#10;        } else {&#10;            LivenessResult.FAILURE // Cannot determine smile if probability is not available&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extracts and preprocesses face bitmap for consistent embedding generation&#10;     * @param face Detected face from ML Kit&#10;     * @param image Source bitmap from camera&#10;     * @return Preprocessed face bitmap or null if extraction fails&#10;     */&#10;    fun extractFaceBitmap(face: Face, image: Bitmap): Bitmap? {&#10;        return try {&#10;            val boundingBox = face.boundingBox&#10;&#10;            // Add padding around the face for better context (10% on each side)&#10;            val padding = (boundingBox.width() * 0.1f).toInt()&#10;&#10;            // Calculate expanded bounding box with padding&#10;            val left = maxOf(0, boundingBox.left - padding)&#10;            val top = maxOf(0, boundingBox.top - padding)&#10;            val right = minOf(image.width, boundingBox.right + padding)&#10;            val bottom = minOf(image.height, boundingBox.bottom + padding)&#10;&#10;            // Validate that we have a valid crop area&#10;            if (left &lt; right &amp;&amp; top &lt; bottom) {&#10;                // Extract face with padding&#10;                val croppedBitmap =&#10;                    Bitmap.createBitmap(image, left, top, right - left, bottom - top)&#10;&#10;                // Standardisasi ukuran dan format&#10;                val standardizedBitmap = standardizeFaceBitmap(croppedBitmap)&#10;&#10;                // Clean up intermediate bitmap&#10;                if (croppedBitmap != standardizedBitmap) {&#10;                    croppedBitmap.recycle()&#10;                }&#10;&#10;                standardizedBitmap&#10;            } else {&#10;                null&#10;            }&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Standardizes face bitmap to consistent size and format&#10;     * This ensures consistent preprocessing for both profile and camera images&#10;     */&#10;    private fun standardizeFaceBitmap(faceBitmap: Bitmap): Bitmap {&#10;        // PERBAIKAN: Gunakan ukuran yang sama dengan FaceProcessor (112x112)&#10;        val standardWidth = 112  // Sama dengan IMAGE_SIZE di FaceProcessor&#10;        val standardHeight = 112  // Sama dengan IMAGE_SIZE di FaceProcessor&#10;&#10;        return try {&#10;            // Resize to standard dimensions with high quality&#10;            Bitmap.createScaledBitmap(faceBitmap, standardWidth, standardHeight, true)&#10;        } catch (e: Exception) {&#10;            faceBitmap // Return original if standardization fails&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Checks if a face is well-positioned for verification&#10;     * @param face Detected face&#10;     * @param imageWidth Width of the camera frame&#10;     * @param imageHeight Height of the camera frame&#10;     * @return true if face is properly positioned&#10;     */&#10;    fun isFaceWellPositioned(face: Face, imageWidth: Int, imageHeight: Int): Boolean {&#10;        val boundingBox = face.boundingBox&#10;        val faceWidth = boundingBox.width()&#10;        val faceHeight = boundingBox.height()&#10;&#10;        // Check if face is not too small or too large&#10;        val minFaceSize = minOf(imageWidth, imageHeight) * 0.2f&#10;        val maxFaceSize = minOf(imageWidth, imageHeight) * 0.8f&#10;        val faceSize = minOf(faceWidth, faceHeight)&#10;&#10;        if (faceSize &lt; minFaceSize || faceSize &gt; maxFaceSize) {&#10;            return false&#10;        }&#10;&#10;        // Check if face is roughly centered&#10;        val faceCenterX = boundingBox.centerX()&#10;        val faceCenterY = boundingBox.centerY()&#10;        val imageCenterX = imageWidth / 2f&#10;        val imageCenterY = imageHeight / 2f&#10;&#10;        val maxOffsetX = imageWidth * 0.25f&#10;        val maxOffsetY = imageHeight * 0.25f&#10;&#10;        return kotlin.math.abs(faceCenterX - imageCenterX) &lt; maxOffsetX &amp;&amp;&#10;                kotlin.math.abs(faceCenterY - imageCenterY) &lt; maxOffsetY&#10;    }&#10;&#10;    /**&#10;     * Clean up resources when done&#10;     * PERBAIKAN: Tambahkan null check&#10;     */&#10;    fun release() {&#10;        try {&#10;            _faceDetector?.close()&#10;            _faceDetector = null&#10;        } catch (e: Exception) {&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/repository/attendance/AttendanceRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/data/repository/attendance/AttendanceRepositoryImpl.kt" />
              <option name="originalContent" value="package com.example.infinite_track.data.repository.attendance&#10;&#10;import android.util.Log&#10;import com.example.infinite_track.data.mapper.attendance.toActiveSession&#10;import com.example.infinite_track.data.mapper.attendance.toDomain&#10;import com.example.infinite_track.data.mapper.attendance.toDto&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.data.soucre.network.request.CheckOutRequestDto&#10;import com.example.infinite_track.data.soucre.network.request.LocationEventRequest&#10;import com.example.infinite_track.data.soucre.network.retrofit.ApiService&#10;import com.example.infinite_track.domain.model.attendance.ActiveAttendanceSession&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.repository.AttendanceRepository&#10;import kotlinx.coroutines.flow.first&#10;&#10;@Singleton&#10;class AttendanceRepositoryImpl @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val attendancePreference: AttendancePreference&#10;) : AttendanceRepository {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceRepository&quot;&#10;    }&#10;&#10;    /**&#10;     * Gets the current day's attendance status&#10;            // Convert domain model to DTO using mapper&#10;            val requestDto = request.toDto()&#10;&#10;            // Call API for check-in - backend handles location validation&#10;            val response = apiService.checkIn(requestDto)&#10;&#10;            if (response.success) {&#10;                // Save the attendance ID for later checkout&#10;                attendancePreference.saveActiveAttendanceId(response.data.idAttendance)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Check-in successful, saved attendance ID: ${response.data.idAttendance}&quot;&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-in&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-out operation with attendanceId and coordinates&#10;     * Backend will handle location validation for checkout&#10;     */&#10;    override suspend fun checkOut(&#10;        attendanceId: Int,&#10;        latitude: Double,&#10;        longitude: Double&#10;    ): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Create checkout request DTO with coordinates&#10;            val checkOutRequestDto = CheckOutRequestDto(&#10;                latitude = latitude,&#10;                longitude = longitude&#10;            )&#10;&#10;            // Call API for check-out with attendanceId in URL and coordinates in body&#10;            val response = apiService.checkOut(attendanceId, checkOutRequestDto)&#10;&#10;            if (response.success) {&#10;                // Clear the active attendance ID&#10;                attendancePreference.clearActiveAttendanceId()&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-out&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieves the active attendance ID from preferences&#10;     */&#10;    override suspend fun getActiveAttendanceId(): Int? {&#10;        return try {&#10;            attendancePreference.getActiveAttendanceId().first()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting active attendance ID&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sends location event (ENTER/EXIT) to backend&#10;     */&#10;    override suspend fun sendLocationEvent(request: LocationEventRequest): Result&lt;Unit&gt; {&#10;        return try {&#10;            val response = apiService.sendLocationEvent(request)&#10;            if (response.isSuccessful) {&#10;                Log.d(TAG, &quot;Location event sent successfully: ${request.eventType}&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to send location event: ${response.code()} ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending location event&quot;, e)&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.data.repository.attendance&#10;&#10;import android.util.Log&#10;import com.example.infinite_track.data.mapper.attendance.toActiveSession&#10;import com.example.infinite_track.data.mapper.attendance.toDomain&#10;import com.example.infinite_track.data.mapper.attendance.toDto&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.data.soucre.network.request.CheckOutRequestDto&#10;import com.example.infinite_track.data.soucre.network.request.LocationEventRequest&#10;import com.example.infinite_track.data.soucre.network.retrofit.ApiService&#10;import com.example.infinite_track.domain.model.attendance.ActiveAttendanceSession&#10;import com.example.infinite_track.domain.model.attendance.AttendanceRequestModel&#10;import com.example.infinite_track.domain.model.attendance.TodayStatus&#10;import com.example.infinite_track.domain.repository.AttendanceRepository&#10;import kotlinx.coroutines.flow.first&#10;import org.json.JSONObject&#10;import retrofit2.HttpException&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AttendanceRepositoryImpl @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val attendancePreference: AttendancePreference&#10;) : AttendanceRepository {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AttendanceRepository&quot;&#10;    }&#10;&#10;    /**&#10;     * Extract error message from HTTP response body&#10;     */&#10;    private fun extractErrorMessage(exception: HttpException): String {&#10;        return try {&#10;            val errorBody = exception.response()?.errorBody()?.string()&#10;            if (!errorBody.isNullOrEmpty()) {&#10;                val jsonObject = JSONObject(errorBody)&#10;                val message = jsonObject.optString(&quot;message&quot;, &quot;&quot;)&#10;                if (message.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;Extracted error message: $message&quot;)&#10;                    return message&#10;                }&#10;            }&#10;            // Fallback to HTTP status message&#10;            &quot;HTTP ${exception.code()} ${exception.message()}&quot;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to extract error message&quot;, e)&#10;            &quot;HTTP ${exception.code()} ${exception.message()}&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the current day's attendance status&#10;     */&#10;    override suspend fun getTodayStatus(): Result&lt;TodayStatus&gt; {&#10;        return try {&#10;            val response = apiService.getTodayStatus()&#10;            if (response.success) {&#10;                // Convert DTO to domain model using mapper&#10;                Result.success(response.data.toDomain())&#10;            } else {&#10;                Result.failure(Exception(response.message ?: &quot;Unknown error&quot;))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error getting today's status&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting today's status&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-in operation - simplified without client-side location validation&#10;     * Backend will handle all location validation&#10;     */&#10;    override suspend fun checkIn(request: AttendanceRequestModel): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Convert domain model to DTO using mapper&#10;            val requestDto = request.toDto()&#10;&#10;            // Call API for check-in - backend handles location validation&#10;            val response = apiService.checkIn(requestDto)&#10;&#10;            if (response.success) {&#10;                // Save the attendance ID for later checkout&#10;                attendancePreference.saveActiveAttendanceId(response.data.idAttendance)&#10;                Log.d(&#10;                    TAG,&#10;                    &quot;Check-in successful, saved attendance ID: ${response.data.idAttendance}&quot;&#10;                )&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error during check-in&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-in&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Performs check-out operation with attendanceId and coordinates&#10;     * Backend will handle location validation for checkout&#10;     */&#10;    override suspend fun checkOut(&#10;        attendanceId: Int,&#10;        latitude: Double,&#10;        longitude: Double&#10;    ): Result&lt;ActiveAttendanceSession&gt; {&#10;        return try {&#10;            // Create checkout request DTO with coordinates&#10;            val checkOutRequestDto = CheckOutRequestDto(&#10;                latitude = latitude,&#10;                longitude = longitude&#10;            )&#10;&#10;            // Call API for check-out with attendanceId in URL and coordinates in body&#10;            val response = apiService.checkOut(attendanceId, checkOutRequestDto)&#10;&#10;            if (response.success) {&#10;                // Clear the active attendance ID&#10;                attendancePreference.clearActiveAttendanceId()&#10;                Log.d(TAG, &quot;Check-out successful, cleared attendance ID&quot;)&#10;&#10;                // Convert DTO to ActiveAttendanceSession domain model using mapper&#10;                Result.success(response.data.toActiveSession())&#10;            } else {&#10;                Result.failure(Exception(response.message))&#10;            }&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;HTTP Error during check-out&quot;, e)&#10;            val errorMessage = extractErrorMessage(e)&#10;            Result.failure(Exception(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error during check-out&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retrieves the active attendance ID from preferences&#10;     */&#10;    override suspend fun getActiveAttendanceId(): Int? {&#10;        return try {&#10;            attendancePreference.getActiveAttendanceId().first()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting active attendance ID&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sends location event (ENTER/EXIT) to backend&#10;     */&#10;    override suspend fun sendLocationEvent(request: LocationEventRequest): Result&lt;Unit&gt; {&#10;        return try {&#10;            val response = apiService.sendLocationEvent(request)&#10;            if (response.isSuccessful) {&#10;                Log.d(TAG, &quot;Location event sent successfully: ${request.eventType}&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Failed to send location event: ${response.code()} ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending location event&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/di/UseCaseModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/di/UseCaseModule.kt" />
              <option name="originalContent" value="package com.example.infinite_track.di&#10;&#10;import com.example.infinite_track.data.face.FaceProcessor&#10;import com.example.infinite_track.data.soucre.local.room.UserDao&#10;import com.example.infinite_track.domain.repository.AttendanceHistoryRepository&#10;import com.example.infinite_track.domain.repository.AttendanceRepository&#10;import com.example.infinite_track.domain.repository.AuthRepository&#10;import com.example.infinite_track.domain.repository.BookingRepository&#10;import com.example.infinite_track.domain.repository.ContactRepository&#10;import com.example.infinite_track.domain.repository.LocalizationRepository&#10;import com.example.infinite_track.domain.repository.LocationRepository&#10;import com.example.infinite_track.domain.repository.ProfileRepository&#10;import com.example.infinite_track.domain.repository.WfaRepository&#10;import com.example.infinite_track.domain.use_case.attendance.CheckInUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.CheckOutUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.GetTodayStatusUseCase&#10;import com.example.infinite_track.domain.use_case.auth.CheckSessionUseCase&#10;import com.example.infinite_track.domain.use_case.auth.GenerateAndSaveEmbeddingUseCase&#10;import com.example.infinite_track.domain.use_case.auth.GetLoggedInUserUseCase&#10;import com.example.infinite_track.domain.use_case.auth.LoginUseCase&#10;import com.example.infinite_track.domain.use_case.auth.LogoutUseCase&#10;import com.example.infinite_track.domain.use_case.auth.VerifyFaceUseCase&#10;import com.example.infinite_track.domain.use_case.booking.GetBookingHistoryUseCase&#10;import com.example.infinite_track.domain.use_case.booking.SubmitWfaBookingUseCase&#10;import com.example.infinite_track.domain.use_case.contact.GetContactsUseCase&#10;import com.example.infinite_track.domain.use_case.history.GetAttendanceHistoryUseCase&#10;import com.example.infinite_track.domain.use_case.language.GetSelectedLanguageUseCase&#10;import com.example.infinite_track.domain.use_case.language.SetSelectedLanguageUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentAddressUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentCoordinatesUseCase&#10;import com.example.infinite_track.domain.use_case.location.SearchLocationUseCase&#10;import com.example.infinite_track.domain.use_case.profile.UpdateProfileUseCase&#10;import com.example.infinite_track.domain.use_case.wfa.GetWfaRecommendationsUseCase&#10;import com.example.infinite_track.presentation.geofencing.GeofenceManager&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object UseCaseModule {&#10;&#10;    // Provide the Generate and Save Embedding Use Case&#10;    @Provides&#10;    fun provideGenerateAndSaveEmbeddingUseCase(&#10;        faceProcessor: FaceProcessor,&#10;        authRepository: AuthRepository&#10;    ): GenerateAndSaveEmbeddingUseCase {&#10;        return GenerateAndSaveEmbeddingUseCase(faceProcessor, authRepository)&#10;    }&#10;&#10;    // Provide the Verify Face Use Case&#10;    @Provides&#10;    fun provideVerifyFaceUseCase(&#10;        faceProcessor: FaceProcessor,&#10;        authRepository: AuthRepository&#10;    ): VerifyFaceUseCase {&#10;        return VerifyFaceUseCase(faceProcessor, authRepository)&#10;    }&#10;&#10;    // Provide the Login Use Case&#10;    @Provides&#10;    fun provideLoginUseCase(&#10;        authRepository: AuthRepository,&#10;        faceProcessor: FaceProcessor&#10;    ): LoginUseCase {&#10;        return LoginUseCase(authRepository, faceProcessor)&#10;    }&#10;&#10;    // Provide the Check Session Use Case (Updated to use GenerateAndSaveEmbeddingUseCase)&#10;    @Provides&#10;    fun provideCheckSessionUseCase(&#10;        authRepository: AuthRepository,&#10;        generateAndSaveEmbeddingUseCase: GenerateAndSaveEmbeddingUseCase&#10;    ): CheckSessionUseCase {&#10;        return CheckSessionUseCase(authRepository, generateAndSaveEmbeddingUseCase)&#10;    }&#10;&#10;    // Provide the Logout Use Case&#10;    @Provides&#10;    fun provideLogoutUseCase(authRepository: AuthRepository): LogoutUseCase {&#10;        return LogoutUseCase(authRepository)&#10;    }&#10;&#10;    // Provide the Contacts Use Case&#10;    @Provides&#10;    fun provideGetContactsUseCase(contactRepository: ContactRepository): GetContactsUseCase {&#10;        return GetContactsUseCase(contactRepository)&#10;    }&#10;&#10;    // Provide the GetLoggedInUser Use Case&#10;    @Provides&#10;    fun provideGetLoggedInUserUseCase(authRepository: AuthRepository): GetLoggedInUserUseCase {&#10;        return GetLoggedInUserUseCase(authRepository)&#10;    }&#10;&#10;    // Provide the Language Use Cases&#10;    @Provides&#10;    fun provideGetSelectedLanguageUseCase(localizationRepository: LocalizationRepository): GetSelectedLanguageUseCase {&#10;        return GetSelectedLanguageUseCase(localizationRepository)&#10;    }&#10;&#10;    @Provides&#10;    fun provideSetSelectedLanguageUseCase(localizationRepository: LocalizationRepository): SetSelectedLanguageUseCase {&#10;        return SetSelectedLanguageUseCase(localizationRepository)&#10;    }&#10;&#10;    // Provide the Update Profile Use Case&#10;    @Provides&#10;    fun provideUpdateProfileUseCase(profileRepository: ProfileRepository): UpdateProfileUseCase {&#10;        return UpdateProfileUseCase(profileRepository)&#10;    }&#10;&#10;    // Provide the Attendance History Use Case&#10;    @Provides&#10;    fun provideGetAttendanceHistoryUseCase(&#10;        attendanceHistoryRepository: AttendanceHistoryRepository&#10;    ): GetAttendanceHistoryUseCase {&#10;        return GetAttendanceHistoryUseCase(attendanceHistoryRepository)&#10;    }&#10;&#10;    // Provide the Get Current Address Use Case&#10;    @Provides&#10;    fun provideGetCurrentAddressUseCase(locationRepository: LocationRepository): GetCurrentAddressUseCase {&#10;        return GetCurrentAddressUseCase(locationRepository)&#10;    }&#10;&#10;    // Provide the Get Current Coordinates Use Case&#10;    @Provides&#10;    fun provideGetCurrentCoordinatesUseCase(&#10;        fusedLocationProviderClient: FusedLocationProviderClient,&#10;        userDao: UserDao&#10;    ): GetCurrentCoordinatesUseCase {&#10;        return GetCurrentCoordinatesUseCase(fusedLocationProviderClient, userDao)&#10;    }&#10;&#10;    // Provide the Get Today Status Use Case&#10;    @Provides&#10;    fun provideGetTodayStatusUseCase(attendanceRepository: AttendanceRepository): GetTodayStatusUseCase {&#10;        return GetTodayStatusUseCase(attendanceRepository)&#10;    }&#10;&#10;    // Provide the WFA Recommendations Use Case&#10;    @Provides&#10;    fun provideGetWfaRecommendationsUseCase(&#10;        wfaRepository: WfaRepository&#10;    ): GetWfaRecommendationsUseCase {&#10;        return GetWfaRecommendationsUseCase(wfaRepository)&#10;    }&#10;&#10;    // Provide the Search Location Use Case&#10;    @Provides&#10;    fun provideSearchLocationUseCase(locationRepository: LocationRepository): SearchLocationUseCase {&#10;        return SearchLocationUseCase(locationRepository)&#10;    }&#10;&#10;    // Provide the Get Booking History Use Case&#10;    @Provides&#10;    fun provideGetBookingHistoryUseCase(&#10;        bookingRepository: BookingRepository&#10;    ): GetBookingHistoryUseCase {&#10;        return GetBookingHistoryUseCase(bookingRepository)&#10;    }&#10;&#10;    // Provide the Submit WFA Booking Use Case&#10;    @Provides&#10;    fun provideSubmitWfaBookingUseCase(&#10;        bookingRepository: BookingRepository&#10;    ): SubmitWfaBookingUseCase {&#10;        return SubmitWfaBookingUseCase(bookingRepository)&#10;    }&#10;&#10;    // Provide the Check In Use Case&#10;    @Provides&#10;    fun provideCheckInUseCase(&#10;        attendanceRepository: AttendanceRepository,&#10;        getCurrentCoordinatesUseCase: GetCurrentCoordinatesUseCase,&#10;        geofenceManager: GeofenceManager&#10;    ): CheckInUseCase {&#10;        return CheckInUseCase(attendanceRepository, getCurrentCoordinatesUseCase, geofenceManager)&#10;    }&#10;&#10;    // Provide the Check Out Use Case&#10;    @Provides&#10;    fun provideCheckOutUseCase(&#10;        attendanceRepository: AttendanceRepository,&#10;        getCurrentCoordinatesUseCase: GetCurrentCoordinatesUseCase,&#10;        geofenceManager: GeofenceManager&#10;    ): CheckOutUseCase {&#10;        return CheckOutUseCase(attendanceRepository, getCurrentCoordinatesUseCase, geofenceManager)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.infinite_track.di&#10;&#10;import com.example.infinite_track.data.face.FaceProcessor&#10;import com.example.infinite_track.data.soucre.local.preferences.AttendancePreference&#10;import com.example.infinite_track.data.soucre.local.room.UserDao&#10;import com.example.infinite_track.domain.repository.AttendanceHistoryRepository&#10;import com.example.infinite_track.domain.repository.AttendanceRepository&#10;import com.example.infinite_track.domain.repository.AuthRepository&#10;import com.example.infinite_track.domain.repository.BookingRepository&#10;import com.example.infinite_track.domain.repository.ContactRepository&#10;import com.example.infinite_track.domain.repository.LocalizationRepository&#10;import com.example.infinite_track.domain.repository.LocationRepository&#10;import com.example.infinite_track.domain.repository.ProfileRepository&#10;import com.example.infinite_track.domain.repository.WfaRepository&#10;import com.example.infinite_track.domain.use_case.attendance.CheckInUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.CheckOutUseCase&#10;import com.example.infinite_track.domain.use_case.attendance.GetTodayStatusUseCase&#10;import com.example.infinite_track.domain.use_case.auth.CheckSessionUseCase&#10;import com.example.infinite_track.domain.use_case.auth.GenerateAndSaveEmbeddingUseCase&#10;import com.example.infinite_track.domain.use_case.auth.GetLoggedInUserUseCase&#10;import com.example.infinite_track.domain.use_case.auth.LoginUseCase&#10;import com.example.infinite_track.domain.use_case.auth.LogoutUseCase&#10;import com.example.infinite_track.domain.use_case.auth.VerifyFaceUseCase&#10;import com.example.infinite_track.domain.use_case.booking.GetBookingHistoryUseCase&#10;import com.example.infinite_track.domain.use_case.booking.SubmitWfaBookingUseCase&#10;import com.example.infinite_track.domain.use_case.contact.GetContactsUseCase&#10;import com.example.infinite_track.domain.use_case.history.GetAttendanceHistoryUseCase&#10;import com.example.infinite_track.domain.use_case.language.GetSelectedLanguageUseCase&#10;import com.example.infinite_track.domain.use_case.language.SetSelectedLanguageUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentAddressUseCase&#10;import com.example.infinite_track.domain.use_case.location.GetCurrentCoordinatesUseCase&#10;import com.example.infinite_track.domain.use_case.location.SearchLocationUseCase&#10;import com.example.infinite_track.domain.use_case.profile.UpdateProfileUseCase&#10;import com.example.infinite_track.domain.use_case.wfa.GetWfaRecommendationsUseCase&#10;import com.example.infinite_track.presentation.geofencing.GeofenceManager&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object UseCaseModule {&#10;&#10;    // Provide the Generate and Save Embedding Use Case&#10;    @Provides&#10;    fun provideGenerateAndSaveEmbeddingUseCase(&#10;        faceProcessor: FaceProcessor,&#10;        authRepository: AuthRepository&#10;    ): GenerateAndSaveEmbeddingUseCase {&#10;        return GenerateAndSaveEmbeddingUseCase(faceProcessor, authRepository)&#10;    }&#10;&#10;    // Provide the Verify Face Use Case&#10;    @Provides&#10;    fun provideVerifyFaceUseCase(&#10;        faceProcessor: FaceProcessor,&#10;        authRepository: AuthRepository&#10;    ): VerifyFaceUseCase {&#10;        return VerifyFaceUseCase(faceProcessor, authRepository)&#10;    }&#10;&#10;    // Provide the Login Use Case&#10;    @Provides&#10;    fun provideLoginUseCase(&#10;        authRepository: AuthRepository,&#10;        faceProcessor: FaceProcessor&#10;    ): LoginUseCase {&#10;        return LoginUseCase(authRepository, faceProcessor)&#10;    }&#10;&#10;    // Provide the Check Session Use Case (Updated to use GenerateAndSaveEmbeddingUseCase)&#10;    @Provides&#10;    fun provideCheckSessionUseCase(&#10;        authRepository: AuthRepository,&#10;        generateAndSaveEmbeddingUseCase: GenerateAndSaveEmbeddingUseCase&#10;    ): CheckSessionUseCase {&#10;        return CheckSessionUseCase(authRepository, generateAndSaveEmbeddingUseCase)&#10;    }&#10;&#10;    // Provide the Logout Use Case&#10;    @Provides&#10;    fun provideLogoutUseCase(authRepository: AuthRepository): LogoutUseCase {&#10;        return LogoutUseCase(authRepository)&#10;    }&#10;&#10;    // Provide the Contacts Use Case&#10;    @Provides&#10;    fun provideGetContactsUseCase(contactRepository: ContactRepository): GetContactsUseCase {&#10;        return GetContactsUseCase(contactRepository)&#10;    }&#10;&#10;    // Provide the GetLoggedInUser Use Case&#10;    @Provides&#10;    fun provideGetLoggedInUserUseCase(authRepository: AuthRepository): GetLoggedInUserUseCase {&#10;        return GetLoggedInUserUseCase(authRepository)&#10;    }&#10;&#10;    // Provide the Language Use Cases&#10;    @Provides&#10;    fun provideGetSelectedLanguageUseCase(localizationRepository: LocalizationRepository): GetSelectedLanguageUseCase {&#10;        return GetSelectedLanguageUseCase(localizationRepository)&#10;    }&#10;&#10;    @Provides&#10;    fun provideSetSelectedLanguageUseCase(localizationRepository: LocalizationRepository): SetSelectedLanguageUseCase {&#10;        return SetSelectedLanguageUseCase(localizationRepository)&#10;    }&#10;&#10;    // Provide the Update Profile Use Case&#10;    @Provides&#10;    fun provideUpdateProfileUseCase(profileRepository: ProfileRepository): UpdateProfileUseCase {&#10;        return UpdateProfileUseCase(profileRepository)&#10;    }&#10;&#10;    // Provide the Attendance History Use Case&#10;    @Provides&#10;    fun provideGetAttendanceHistoryUseCase(&#10;        attendanceHistoryRepository: AttendanceHistoryRepository&#10;    ): GetAttendanceHistoryUseCase {&#10;        return GetAttendanceHistoryUseCase(attendanceHistoryRepository)&#10;    }&#10;&#10;    // Provide the Get Current Address Use Case&#10;    @Provides&#10;    fun provideGetCurrentAddressUseCase(locationRepository: LocationRepository): GetCurrentAddressUseCase {&#10;        return GetCurrentAddressUseCase(locationRepository)&#10;    }&#10;&#10;    // Provide the Get Current Coordinates Use Case&#10;    @Provides&#10;    fun provideGetCurrentCoordinatesUseCase(&#10;        fusedLocationProviderClient: FusedLocationProviderClient,&#10;        userDao: UserDao&#10;    ): GetCurrentCoordinatesUseCase {&#10;        return GetCurrentCoordinatesUseCase(fusedLocationProviderClient, userDao)&#10;    }&#10;&#10;    // Provide the Get Today Status Use Case&#10;    @Provides&#10;    fun provideGetTodayStatusUseCase(attendanceRepository: AttendanceRepository): GetTodayStatusUseCase {&#10;        return GetTodayStatusUseCase(attendanceRepository)&#10;    }&#10;&#10;    // Provide the WFA Recommendations Use Case&#10;    @Provides&#10;    fun provideGetWfaRecommendationsUseCase(&#10;        wfaRepository: WfaRepository&#10;    ): GetWfaRecommendationsUseCase {&#10;        return GetWfaRecommendationsUseCase(wfaRepository)&#10;    }&#10;&#10;    // Provide the Search Location Use Case&#10;    @Provides&#10;    fun provideSearchLocationUseCase(locationRepository: LocationRepository): SearchLocationUseCase {&#10;        return SearchLocationUseCase(locationRepository)&#10;    }&#10;&#10;    // Provide the Get Booking History Use Case&#10;    @Provides&#10;    fun provideGetBookingHistoryUseCase(&#10;        bookingRepository: BookingRepository&#10;    ): GetBookingHistoryUseCase {&#10;        return GetBookingHistoryUseCase(bookingRepository)&#10;    }&#10;&#10;    // Provide the Submit WFA Booking Use Case&#10;    @Provides&#10;    fun provideSubmitWfaBookingUseCase(&#10;        bookingRepository: BookingRepository&#10;    ): SubmitWfaBookingUseCase {&#10;        return SubmitWfaBookingUseCase(bookingRepository)&#10;    }&#10;&#10;    // Provide the Check In Use Case&#10;    @Provides&#10;    fun provideCheckInUseCase(&#10;        attendanceRepository: AttendanceRepository,&#10;        getCurrentCoordinatesUseCase: GetCurrentCoordinatesUseCase,&#10;        geofenceManager: GeofenceManager,&#10;        attendancePreference: AttendancePreference&#10;    ): CheckInUseCase {&#10;        return CheckInUseCase(attendanceRepository, getCurrentCoordinatesUseCase, geofenceManager, attendancePreference)&#10;    }&#10;&#10;    // Provide the Check Out Use Case&#10;    @Provides&#10;    fun provideCheckOutUseCase(&#10;        attendanceRepository: AttendanceRepository,&#10;        getCurrentCoordinatesUseCase: GetCurrentCoordinatesUseCase,&#10;        geofenceManager: GeofenceManager,&#10;        attendancePreference: AttendancePreference&#10;    ): CheckOutUseCase {&#10;        return CheckOutUseCase(attendanceRepository, getCurrentCoordinatesUseCase, geofenceManager, attendancePreference)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceManager.kt" />
              <option name="originalContent" value="package com.example.infinite_track.presentation.geofencing&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.content.ContextCompat&#10;import com.google.android.gms.common.api.ApiException&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofenceStatusCodes&#10;import com.google.android.gms.location.GeofencingRequest&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.LocationSettingsRequest&#10;import com.google.android.gms.location.Priority&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.math.max&#10;&#10;@Singleton&#10;class GeofenceManager @Inject constructor(@ApplicationContext private val context: Context) {&#10;&#10;    private val geofencingClient = LocationServices.getGeofencingClient(context)&#10;    private val settingsClient = LocationServices.getSettingsClient(context)&#10;    private val TAG = &quot;GeofenceManager&quot;&#10;&#10;    private val geofencePendingIntent: PendingIntent by lazy {&#10;        val intent = Intent(context, GeofenceBroadcastReceiver::class.java)&#10;        PendingIntent.getBroadcast(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;    }&#10;&#10;    private fun hasForegroundLocationPermission(): Boolean {&#10;        val fine = ContextCompat.checkSelfPermission(&#10;            context,&#10;            android.Manifest.permission.ACCESS_FINE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;        val coarse = ContextCompat.checkSelfPermission(&#10;            context,&#10;            android.Manifest.permission.ACCESS_COARSE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;        return fine || coarse&#10;    }&#10;&#10;    private fun hasBackgroundLocationPermission(): Boolean {&#10;        return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                android.Manifest.permission.ACCESS_BACKGROUND_LOCATION&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        } else true&#10;    }&#10;&#10;    /**&#10;     * Remove all geofences registered by this application&#10;     * This ensures we never hit the system limit of ~100 geofences&#10;     */&#10;    fun removeAllGeofences() {&#10;        geofencingClient.removeGeofences(geofencePendingIntent).run {&#10;            addOnSuccessListener {&#10;                Log.d(TAG, &quot;Semua geofence berhasil dihapus&quot;)&#10;            }&#10;            addOnFailureListener { exception -&gt;&#10;                Log.e(TAG, &quot;Gagal menghapus semua geofence&quot;, exception)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun addGeofence(id: String, latitude: Double, longitude: Double, radius: Float) {&#10;        // Permission guards&#10;        if (!hasForegroundLocationPermission()) {&#10;            Log.e(TAG, &quot;Tidak ada izin lokasi (FINE/COARSE). Geofence tidak dapat ditambahkan.&quot;)&#10;            return&#10;        }&#10;        if (!hasBackgroundLocationPermission()) {&#10;            Log.e(TAG, &quot;Tidak ada izin ACCESS_BACKGROUND_LOCATION. Geofence gagal (API 29+).&quot;)&#10;            return&#10;        }&#10;&#10;        val safeRadius = max(100f, radius)&#10;&#10;        // Check device location settings first (GPS/location must be ON)&#10;        val locationRequest = LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 10_000L)&#10;            .setMinUpdateIntervalMillis(5_000L)&#10;            .build()&#10;        val settingsRequest = LocationSettingsRequest.Builder()&#10;            .addLocationRequest(locationRequest)&#10;            .build()&#10;&#10;        settingsClient.checkLocationSettings(settingsRequest)&#10;            .addOnSuccessListener {&#10;                // STEP 1: Always remove all existing geofences first (clean slate approach)&#10;                Log.d(TAG, &quot;Membersihkan semua geofence sebelum menambah yang baru...&quot;)&#10;&#10;                geofencingClient.removeGeofences(geofencePendingIntent).run {&#10;                    addOnSuccessListener {&#10;                        Log.d(TAG, &quot;Semua geofence berhasil dihapus, sekarang menambah geofence baru...&quot;)&#10;&#10;                        // STEP 2: Create and add the new geofence ONLY after removal is successful&#10;                        val geofence = Geofence.Builder()&#10;                            .setRequestId(id)&#10;                            .setCircularRegion(latitude, longitude, safeRadius)&#10;                            .setExpirationDuration(Geofence.NEVER_EXPIRE)&#10;                            .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER or Geofence.GEOFENCE_TRANSITION_EXIT)&#10;                            .build()&#10;&#10;                        val geofencingRequest = GeofencingRequest.Builder()&#10;                            .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)&#10;                            .addGeofence(geofence)&#10;                            .build()&#10;&#10;                        geofencingClient.addGeofences(geofencingRequest, geofencePendingIntent).run {&#10;                            addOnSuccessListener {&#10;                                Log.d(&#10;                                    TAG,&#10;                                    &quot;Geofence berhasil ditambahkan: $id (lat: $latitude, lng: $longitude, radius: ${safeRadius}m)&quot;&#10;                                )&#10;                            }&#10;                            addOnFailureListener { exception -&gt;&#10;                                val status = (exception as? ApiException)?.statusCode&#10;                                val statusText = status?.let { GeofenceStatusCodes.getStatusCodeString(it) }&#10;                                Log.e(TAG, &quot;Gagal menambahkan geofence: $id (${status ?: &quot;?&quot;}: ${statusText ?: exception.message})&quot;, exception)&#10;                            }&#10;                        }&#10;                    }&#10;                    addOnFailureListener { exception -&gt;&#10;                        Log.e(&#10;                            TAG,&#10;                            &quot;Gagal menghapus semua geofence, geofence baru tidak akan ditambahkan&quot;,&#10;                            exception&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            .addOnFailureListener { exception -&gt;&#10;                val status = (exception as? ApiException)?.statusCode&#10;                val statusText = status?.let { GeofenceStatusCodes.getStatusCodeString(it) }&#10;                Log.e(TAG, &quot;Location settings tidak memenuhi syarat untuk Geofencing (${status ?: &quot;?&quot;}: ${statusText ?: exception.message}). Pastikan Location diaktifkan.&quot;)&#10;            }&#10;    }&#10;&#10;    fun removeGeofence(id: String) {&#10;        geofencingClient.removeGeofences(listOf(id)).run {&#10;            addOnSuccessListener { Log.d(TAG, &quot;Geofence berhasil dihapus: $id&quot;) }&#10;            addOnFailureListener { Log.e(TAG, &quot;Gagal menghapus geofence: $id&quot;, it) }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.geofencing&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.content.ContextCompat&#10;import com.google.android.gms.common.api.ApiException&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofenceStatusCodes&#10;import com.google.android.gms.location.GeofencingRequest&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationServices&#10;import com.google.android.gms.location.LocationSettingsRequest&#10;import com.google.android.gms.location.Priority&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.math.max&#10;&#10;@Singleton&#10;class GeofenceManager @Inject constructor(@ApplicationContext private val context: Context) {&#10;&#10;    private val geofencingClient = LocationServices.getGeofencingClient(context)&#10;    private val settingsClient = LocationServices.getSettingsClient(context)&#10;    private val TAG = &quot;GeofenceManager&quot;&#10;&#10;    // Mode operasi: full (dengan background) atau limited (foreground only)&#10;    private var operationMode = GeofenceOperationMode.FULL&#10;&#10;    enum class GeofenceOperationMode {&#10;        FULL,       // Background + Foreground&#10;        LIMITED,    // Foreground only&#10;        DISABLED    // No permissions&#10;    }&#10;&#10;    private val geofencePendingIntent: PendingIntent by lazy {&#10;        val intent = Intent(context, GeofenceBroadcastReceiver::class.java)&#10;        PendingIntent.getBroadcast(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Memeriksa izin lokasi foreground (FINE atau COARSE)&#10;     */&#10;    private fun hasForegroundLocationPermission(): Boolean {&#10;        val fine = ContextCompat.checkSelfPermission(&#10;            context,&#10;            android.Manifest.permission.ACCESS_FINE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;        val coarse = ContextCompat.checkSelfPermission(&#10;            context,&#10;            android.Manifest.permission.ACCESS_COARSE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;&#10;        Log.d(TAG, &quot;Permission check - FINE: $fine, COARSE: $coarse&quot;)&#10;        return fine || coarse&#10;    }&#10;&#10;    /**&#10;     * Memeriksa izin background location dengan handling yang lebih baik&#10;     */&#10;    private fun hasBackgroundLocationPermission(): Boolean {&#10;        return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            val hasPermission = ContextCompat.checkSelfPermission(&#10;                context,&#10;                android.Manifest.permission.ACCESS_BACKGROUND_LOCATION&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;&#10;            Log.d(TAG, &quot;Background location permission (API ${Build.VERSION.SDK_INT}): $hasPermission&quot;)&#10;&#10;            if (!hasPermission) {&#10;                Log.w(TAG, &quot;PERINGATAN: ACCESS_BACKGROUND_LOCATION tidak tersedia untuk API ${Build.VERSION.SDK_INT}&quot;)&#10;                Log.w(TAG, &quot;Switching to LIMITED mode - Geofencing hanya aktif saat app foreground&quot;)&#10;            }&#10;&#10;            hasPermission&#10;        } else {&#10;            Log.d(TAG, &quot;Background location permission tidak diperlukan untuk API &lt; 29&quot;)&#10;            true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Menentukan mode operasi berdasarkan izin yang tersedia&#10;     */&#10;    private fun determineOperationMode(): GeofenceOperationMode {&#10;        val foreground = hasForegroundLocationPermission()&#10;        val background = hasBackgroundLocationPermission()&#10;&#10;        return when {&#10;            foreground &amp;&amp; background -&gt; {&#10;                Log.i(TAG, &quot; FULL MODE: Background + Foreground geofencing tersedia&quot;)&#10;                GeofenceOperationMode.FULL&#10;            }&#10;            foreground &amp;&amp; !background -&gt; {&#10;                Log.w(TAG, &quot; LIMITED MODE: Hanya foreground geofencing tersedia&quot;)&#10;                Log.w(TAG, &quot;Geofence akan berfungsi hanya saat aplikasi aktif&quot;)&#10;                GeofenceOperationMode.LIMITED&#10;            }&#10;            else -&gt; {&#10;                Log.e(TAG, &quot; DISABLED MODE: Tidak ada izin lokasi&quot;)&#10;                GeofenceOperationMode.DISABLED&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Memeriksa semua izin yang diperlukan&#10;     */&#10;    fun checkAllPermissions(): Boolean {&#10;        operationMode = determineOperationMode()&#10;&#10;        Log.d(TAG, &quot;Operation Mode: $operationMode&quot;)&#10;&#10;        // Return true jika minimal ada foreground permission&#10;        return operationMode != GeofenceOperationMode.DISABLED&#10;    }&#10;&#10;    /**&#10;     * Get current operation mode&#10;     */&#10;    fun getOperationMode(): GeofenceOperationMode = operationMode&#10;&#10;    /**&#10;     * Check if background geofencing is available&#10;     */&#10;    fun hasBackgroundGeofencing(): Boolean = operationMode == GeofenceOperationMode.FULL&#10;&#10;    /**&#10;     * Remove all geofences registered by this application&#10;     */&#10;    fun removeAllGeofences() {&#10;        geofencingClient.removeGeofences(geofencePendingIntent).run {&#10;            addOnSuccessListener {&#10;                Log.d(TAG, &quot;Semua geofence berhasil dihapus&quot;)&#10;            }&#10;            addOnFailureListener { exception -&gt;&#10;                Log.e(TAG, &quot;Gagal menghapus semua geofence&quot;, exception)&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun addGeofence(id: String, latitude: Double, longitude: Double, radius: Float) {&#10;        Log.d(TAG, &quot;Attempting to add geofence: $id at ($latitude, $longitude) with radius ${radius}m&quot;)&#10;&#10;        // PERBAIKAN: Validasi permission secara mendetail sebelum proceed&#10;        val fineLocationGranted = ContextCompat.checkSelfPermission(&#10;            context,&#10;            android.Manifest.permission.ACCESS_FINE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;&#10;        val coarseLocationGranted = ContextCompat.checkSelfPermission(&#10;            context,&#10;            android.Manifest.permission.ACCESS_COARSE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;&#10;        val backgroundLocationGranted = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                android.Manifest.permission.ACCESS_BACKGROUND_LOCATION&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        } else {&#10;            true // Tidak diperlukan untuk API &lt; 29&#10;        }&#10;&#10;        // Log detailed permission status&#10;        Log.d(TAG, &quot;=== DETAILED PERMISSION CHECK ===&quot;)&#10;        Log.d(TAG, &quot;FINE_LOCATION: $fineLocationGranted&quot;)&#10;        Log.d(TAG, &quot;COARSE_LOCATION: $coarseLocationGranted&quot;)&#10;        Log.d(TAG, &quot;BACKGROUND_LOCATION: $backgroundLocationGranted (API ${Build.VERSION.SDK_INT})&quot;)&#10;&#10;        // Untuk Android 15, FINE_LOCATION wajib untuk geofencing&#10;        if (!fineLocationGranted) {&#10;            Log.e(TAG, &quot; CRITICAL: ACCESS_FINE_LOCATION tidak granted!&quot;)&#10;            Log.e(TAG, &quot;Android 15 memerlukan FINE_LOCATION untuk geofencing&quot;)&#10;            Log.e(TAG, &quot;Solusi: Pastikan user memilih 'Precise location' di pengaturan&quot;)&#10;            return&#10;        }&#10;&#10;        // Determine operation mode based on detailed permissions&#10;        operationMode = when {&#10;            fineLocationGranted &amp;&amp; backgroundLocationGranted -&gt; {&#10;                Log.i(TAG, &quot; FULL MODE: Fine location + Background access&quot;)&#10;                GeofenceOperationMode.FULL&#10;            }&#10;            fineLocationGranted &amp;&amp; !backgroundLocationGranted -&gt; {&#10;                Log.w(TAG, &quot; LIMITED MODE: Fine location only, no background&quot;)&#10;                Log.w(TAG, &quot;Geofence akan berfungsi hanya saat aplikasi aktif&quot;)&#10;                GeofenceOperationMode.LIMITED&#10;            }&#10;            coarseLocationGranted &amp;&amp; !fineLocationGranted -&gt; {&#10;                Log.e(TAG, &quot; INSUFFICIENT: Hanya COARSE_LOCATION tidak cukup untuk geofencing di Android 15&quot;)&#10;                Log.e(TAG, &quot;Solusi: Enable 'Precise location' di pengaturan aplikasi&quot;)&#10;                return&#10;            }&#10;            else -&gt; {&#10;                Log.e(TAG, &quot; NO PERMISSIONS: Tidak ada izin lokasi yang memadai&quot;)&#10;                return&#10;            }&#10;        }&#10;&#10;        // Log operation mode info&#10;        when (operationMode) {&#10;            GeofenceOperationMode.FULL -&gt; {&#10;                Log.i(TAG, &quot; Menggunakan FULL MODE - Background + Foreground geofencing&quot;)&#10;            }&#10;            GeofenceOperationMode.LIMITED -&gt; {&#10;                Log.w(TAG, &quot; Menggunakan LIMITED MODE - Foreground only geofencing&quot;)&#10;                Log.w(TAG, &quot;Untuk pengalaman optimal, berikan izin 'Allow all the time' di pengaturan&quot;)&#10;            }&#10;            GeofenceOperationMode.DISABLED -&gt; return&#10;        }&#10;&#10;        val safeRadius = max(100f, radius)&#10;        Log.d(TAG, &quot;Using safe radius: ${safeRadius}m (minimum 100m)&quot;)&#10;&#10;        // Check device location settings first&#10;        val locationRequest = LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 10_000L)&#10;            .setMinUpdateIntervalMillis(5_000L)&#10;            .build()&#10;        val settingsRequest = LocationSettingsRequest.Builder()&#10;            .addLocationRequest(locationRequest)&#10;            .build()&#10;&#10;        settingsClient.checkLocationSettings(settingsRequest)&#10;            .addOnSuccessListener {&#10;                Log.d(TAG, &quot;Location settings OK, proceeding with geofence setup&quot;)&#10;&#10;                // Clean slate approach - remove all first&#10;                geofencingClient.removeGeofences(geofencePendingIntent).run {&#10;                    addOnSuccessListener {&#10;                        Log.d(TAG, &quot;Existing geofences cleared, adding new geofence...&quot;)&#10;&#10;                        // Create new geofence&#10;                        val geofence = Geofence.Builder()&#10;                            .setRequestId(id)&#10;                            .setCircularRegion(latitude, longitude, safeRadius)&#10;                            .setExpirationDuration(Geofence.NEVER_EXPIRE)&#10;                            .setTransitionTypes(&#10;                                Geofence.GEOFENCE_TRANSITION_ENTER or Geofence.GEOFENCE_TRANSITION_EXIT&#10;                            )&#10;                            .build()&#10;&#10;                        val geofencingRequest = GeofencingRequest.Builder()&#10;                            .setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)&#10;                            .addGeofence(geofence)&#10;                            .build()&#10;&#10;                        geofencingClient.addGeofences(geofencingRequest, geofencePendingIntent).run {&#10;                            addOnSuccessListener {&#10;                                val modeText = if (operationMode == GeofenceOperationMode.FULL) &quot;FULL MODE&quot; else &quot;LIMITED MODE&quot;&#10;                                Log.d(TAG, &quot; BERHASIL: Geofence ditambahkan ($modeText)&quot;)&#10;                                Log.d(TAG, &quot;   - ID: $id&quot;)&#10;                                Log.d(TAG, &quot;   - Lokasi: ($latitude, $longitude)&quot;)&#10;                                Log.d(TAG, &quot;   - Radius: ${safeRadius}m&quot;)&#10;&#10;                                if (operationMode == GeofenceOperationMode.LIMITED) {&#10;                                    Log.w(TAG, &quot;   -  Catatan: Hanya aktif saat aplikasi di foreground&quot;)&#10;                                }&#10;                            }&#10;                            addOnFailureListener { exception -&gt;&#10;                                val status = (exception as? ApiException)?.statusCode&#10;                                val statusText = status?.let { GeofenceStatusCodes.getStatusCodeString(it) }&#10;                                Log.e(TAG, &quot; GAGAL menambahkan geofence: $id&quot;)&#10;                                Log.e(TAG, &quot;Error code: $status ($statusText)&quot;)&#10;                                Log.e(TAG, &quot;Error message: ${exception.message}&quot;)&#10;&#10;                                // Enhanced error handling untuk Android 15&#10;                                when (status) {&#10;                                    GeofenceStatusCodes.GEOFENCE_INSUFFICIENT_LOCATION_PERMISSION -&gt; {&#10;                                        Log.e(TAG, &quot;=== ANDROID 15 PERMISSION TROUBLESHOOTING ===&quot;)&#10;                                        Log.e(TAG, &quot;1. Buka Settings &gt; Apps &gt; Infinite Track &gt; Permissions &gt; Location&quot;)&#10;                                        Log.e(TAG, &quot;2. Pastikan 'Allow all the time' dipilih&quot;)&#10;                                        Log.e(TAG, &quot;3. Pastikan 'Use precise location' diaktifkan&quot;)&#10;                                        Log.e(TAG, &quot;4. Restart aplikasi setelah mengubah pengaturan&quot;)&#10;                                        Log.e(TAG, &quot;5. Jika masih error, coba clear app data dan setup ulang&quot;)&#10;                                    }&#10;                                    GeofenceStatusCodes.GEOFENCE_REQUEST_TOO_FREQUENT -&gt; {&#10;                                        Log.e(TAG, &quot;Solusi: Tunggu 60 detik sebelum menambah geofence lagi&quot;)&#10;                                    }&#10;                                    GeofenceStatusCodes.GEOFENCE_TOO_MANY_GEOFENCES -&gt; {&#10;                                        Log.e(TAG, &quot;Solusi: Hapus geofence yang tidak digunakan (max 100 geofences)&quot;)&#10;                                    }&#10;                                    else -&gt; {&#10;                                        Log.e(TAG, &quot;Solusi: Restart device dan coba lagi&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    addOnFailureListener { exception -&gt;&#10;                        Log.e(TAG, &quot;Gagal menghapus geofence existing&quot;, exception)&#10;                    }&#10;                }&#10;            }&#10;            .addOnFailureListener { exception -&gt;&#10;                val status = (exception as? ApiException)?.statusCode&#10;                val statusText = status?.let { GeofenceStatusCodes.getStatusCodeString(it) }&#10;                Log.e(TAG, &quot;Location settings tidak memenuhi syarat untuk Geofencing&quot;)&#10;                Log.e(TAG, &quot;Error: $status ($statusText)&quot;)&#10;                Log.e(TAG, &quot;Solusi: Pastikan GPS/Location Services diaktifkan di pengaturan device&quot;)&#10;            }&#10;    }&#10;&#10;    fun removeGeofence(id: String) {&#10;        geofencingClient.removeGeofences(listOf(id)).run {&#10;            addOnSuccessListener {&#10;                Log.d(TAG, &quot;Geofence berhasil dihapus: $id&quot;)&#10;            }&#10;            addOnFailureListener {&#10;                Log.e(TAG, &quot;Gagal menghapus geofence: $id&quot;, it)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get user-friendly status message&#10;     */&#10;    fun getStatusMessage(): String {&#10;        return when (operationMode) {&#10;            GeofenceOperationMode.FULL -&gt;&#10;                &quot; Geofencing aktif penuh (background + foreground)&quot;&#10;            GeofenceOperationMode.LIMITED -&gt;&#10;                &quot; Geofencing terbatas (hanya saat aplikasi aktif)\n&quot; +&#10;                &quot;Untuk pengalaman optimal, berikan izin 'Allow all the time'&quot;&#10;            GeofenceOperationMode.DISABLED -&gt;&#10;                &quot; Geofencing tidak tersedia\n&quot; +&#10;                &quot;Berikan izin lokasi untuk menggunakan fitur ini&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceSetupCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceSetupCard.kt" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.geofencing&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Warning&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;&#10;/**&#10; * Composable untuk menampilkan status dan setup Geofencing&#10; * Dengan guidance untuk Android 15 background location permission&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GeofenceSetupCard(&#10;    viewModel: GeofenceSetupViewModel = hiltViewModel(),&#10;    onSetupComplete: () -&gt; Unit = {}&#10;) {&#10;    val context = LocalContext.current&#10;    val setupStatus by viewModel.setupStatus.collectAsState()&#10;    val isLoading by viewModel.isLoading.collectAsState()&#10;    &#10;    LaunchedEffect(Unit) {&#10;        viewModel.checkSetup(context)&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp)&#10;                .verticalScroll(rememberScrollState()),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Header&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.LocationOn,&#10;                    contentDescription = &quot;Location&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;                &#10;                Column {&#10;                    Text(&#10;                        text = &quot;Setup Geofencing&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Text(&#10;                        text = &quot;Presensi otomatis berbasis lokasi&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            Divider()&#10;&#10;            // Status Display&#10;            if (isLoading) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    CircularProgressIndicator(modifier = Modifier.size(24.dp))&#10;                    Text(&quot;Memeriksa konfigurasi geofencing...&quot;)&#10;                }&#10;            } else {&#10;                setupStatus?.let { status -&gt;&#10;                    StatusCard(status = status)&#10;                    &#10;                    if (status.needsAction) {&#10;                        ActionButton(&#10;                            status = status,&#10;                            onActionClick = { &#10;                                viewModel.handleAction(context, status.actionType)&#10;                            }&#10;                        )&#10;                    } else if (status.isReady) {&#10;                        SuccessCard()&#10;                        &#10;                        Button(&#10;                            onClick = onSetupComplete,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        ) {&#10;                            Text(&quot;Lanjutkan&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Business Value Information&#10;            BusinessValueCard()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatusCard(status: GeofenceSetupService.GeofenceSetupStatus) {&#10;    val backgroundColor = when (status.mode) {&#10;        GeofenceManager.GeofenceOperationMode.FULL -&gt; Color(0xFF4CAF50).copy(alpha = 0.1f)&#10;        GeofenceManager.GeofenceOperationMode.LIMITED -&gt; Color(0xFFFF9800).copy(alpha = 0.1f)&#10;        GeofenceManager.GeofenceOperationMode.DISABLED -&gt; Color(0xFFF44336).copy(alpha = 0.1f)&#10;    }&#10;    &#10;    val iconColor = when (status.mode) {&#10;        GeofenceManager.GeofenceOperationMode.FULL -&gt; Color(0xFF4CAF50)&#10;        GeofenceManager.GeofenceOperationMode.LIMITED -&gt; Color(0xFFFF9800)&#10;        GeofenceManager.GeofenceOperationMode.DISABLED -&gt; Color(0xFFF44336)&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(containerColor = backgroundColor),&#10;        shape = RoundedCornerShape(12.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Row(&#10;                verticalAlignment = Alignment.Top,&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = when (status.mode) {&#10;                        GeofenceManager.GeofenceOperationMode.FULL -&gt; Icons.Default.LocationOn&#10;                        else -&gt; Icons.Default.Warning&#10;                    },&#10;                    contentDescription = null,&#10;                    tint = iconColor,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                &#10;                Text(&#10;                    text = status.message,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    lineHeight = 20.sp,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ActionButton(&#10;    status: GeofenceSetupService.GeofenceSetupStatus,&#10;    onActionClick: () -&gt; Unit&#10;) {&#10;    val buttonText = when (status.actionType) {&#10;        GeofenceSetupService.ActionType.REQUEST_FOREGROUND_PERMISSION -&gt; &quot;Berikan Izin Lokasi&quot;&#10;        GeofenceSetupService.ActionType.REQUEST_BACKGROUND_PERMISSION -&gt; &quot;Upgrade ke 'Allow All Time'&quot;&#10;        GeofenceSetupService.ActionType.OPEN_SETTINGS -&gt; &quot;Buka Pengaturan&quot;&#10;        GeofenceSetupService.ActionType.ENABLE_LOCATION_SERVICES -&gt; &quot;Aktifkan GPS&quot;&#10;        GeofenceSetupService.ActionType.NONE -&gt; &quot;Tidak Ada Aksi&quot;&#10;    }&#10;&#10;    OutlinedButton(&#10;        onClick = onActionClick,&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = ButtonDefaults.outlinedButtonColors(&#10;            contentColor = MaterialTheme.colorScheme.primary&#10;        )&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Default.Settings,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(18.dp)&#10;        )&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;        Text(buttonText)&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SuccessCard() {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = Color(0xFF4CAF50).copy(alpha = 0.1f)&#10;        ),&#10;        shape = RoundedCornerShape(12.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.LocationOn,&#10;                contentDescription = null,&#10;                tint = Color(0xFF4CAF50),&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;            &#10;            Text(&#10;                text = &quot; Geofencing siap digunakan!\nSistem presensi otomatis telah aktif.&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = Color(0xFF2E7D32)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun BusinessValueCard() {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)&#10;        ),&#10;        shape = RoundedCornerShape(12.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot; Manfaat Geofencing untuk Bisnis&quot;,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            &#10;            val benefits = listOf(&#10;                &quot; Presensi otomatis tanpa antrean&quot;,&#10;                &quot; Data analytics untuk evaluasi kinerja&quot;,&#10;                &quot; Support Work From Anywhere (WFA)&quot;,&#10;                &quot; Fuzzy AHP scoring objektif&quot;,&#10;                &quot; Efisiensi operasional maksimal&quot;&#10;            )&#10;            &#10;            benefits.forEach { benefit -&gt;&#10;                Text(&#10;                    text = benefit,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    modifier = Modifier.padding(vertical = 2.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceSetupService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceSetupService.kt" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.geofencing&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.provider.Settings&#10;import android.util.Log&#10;import com.example.infinite_track.utils.LocationPermissionHelper&#10;import com.example.infinite_track.utils.PermissionDialogHelper&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Service untuk menangani setup dan konfigurasi Geofencing&#10; * dengan fallback mode untuk berbagai kondisi permission&#10; */&#10;@Singleton&#10;class GeofenceSetupService @Inject constructor(&#10;    private val geofenceManager: GeofenceManager&#10;) {&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;GeofenceSetup&quot;&#10;    }&#10;&#10;    /**&#10;     * Data class untuk status setup geofencing&#10;     */&#10;    data class GeofenceSetupStatus(&#10;        val isReady: Boolean,&#10;        val mode: GeofenceManager.GeofenceOperationMode,&#10;        val message: String,&#10;        val needsAction: Boolean = false,&#10;        val actionType: ActionType = ActionType.NONE&#10;    )&#10;&#10;    enum class ActionType {&#10;        NONE,&#10;        REQUEST_FOREGROUND_PERMISSION,&#10;        REQUEST_BACKGROUND_PERMISSION,&#10;        OPEN_SETTINGS,&#10;        ENABLE_LOCATION_SERVICES&#10;    }&#10;&#10;    /**&#10;     * Comprehensive setup check untuk geofencing&#10;     */&#10;    fun checkGeofenceSetup(context: Context): GeofenceSetupStatus {&#10;        Log.d(TAG, &quot;Starting comprehensive geofence setup check...&quot;)&#10;        &#10;        // Check permissions first&#10;        val hasPermissions = geofenceManager.checkAllPermissions()&#10;        val mode = geofenceManager.getOperationMode()&#10;        &#10;        return when (mode) {&#10;            GeofenceManager.GeofenceOperationMode.FULL -&gt; {&#10;                GeofenceSetupStatus(&#10;                    isReady = true,&#10;                    mode = mode,&#10;                    message = &quot; Geofencing siap sepenuhnya!\nBackground tracking aktif untuk presensi otomatis.&quot;,&#10;                    needsAction = false&#10;                )&#10;            }&#10;            &#10;            GeofenceManager.GeofenceOperationMode.LIMITED -&gt; {&#10;                GeofenceSetupStatus(&#10;                    isReady = true,&#10;                    mode = mode,&#10;                    message = &quot; Geofencing mode terbatas.\n&quot; +&#10;                            &quot;Presensi otomatis hanya aktif saat aplikasi terbuka.\n&quot; +&#10;                            &quot;Untuk pengalaman optimal, berikan izin 'Allow all the time'.&quot;,&#10;                    needsAction = true,&#10;                    actionType = ActionType.REQUEST_BACKGROUND_PERMISSION&#10;                )&#10;            }&#10;            &#10;            GeofenceManager.GeofenceOperationMode.DISABLED -&gt; {&#10;                val foregroundPermission = LocationPermissionHelper.hasForegroundLocationPermissions(context)&#10;                &#10;                if (!foregroundPermission) {&#10;                    GeofenceSetupStatus(&#10;                        isReady = false,&#10;                        mode = mode,&#10;                        message = &quot; Izin lokasi diperlukan.\n&quot; +&#10;                                &quot;Aplikasi memerlukan akses lokasi untuk fitur presensi geofencing.&quot;,&#10;                        needsAction = true,&#10;                        actionType = ActionType.REQUEST_FOREGROUND_PERMISSION&#10;                    )&#10;                } else {&#10;                    GeofenceSetupStatus(&#10;                        isReady = false,&#10;                        mode = mode,&#10;                        message = &quot; Location services tidak aktif.\n&quot; +&#10;                                &quot;Pastikan GPS dan Location Services diaktifkan di pengaturan device.&quot;,&#10;                        needsAction = true,&#10;                        actionType = ActionType.ENABLE_LOCATION_SERVICES&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle action berdasarkan status setup&#10;     */&#10;    fun handleSetupAction(context: Context, actionType: ActionType) {&#10;        when (actionType) {&#10;            ActionType.REQUEST_FOREGROUND_PERMISSION -&gt; {&#10;                Log.d(TAG, &quot;Opening app settings for foreground location permission&quot;)&#10;                openAppLocationSettings(context)&#10;            }&#10;            &#10;            ActionType.REQUEST_BACKGROUND_PERMISSION -&gt; {&#10;                Log.d(TAG, &quot;Showing background location permission dialog&quot;)&#10;                PermissionDialogHelper.showBackgroundLocationPermissionDialog(&#10;                    context = context,&#10;                    onPositiveClick = {&#10;                        openAppLocationSettings(context)&#10;                    }&#10;                )&#10;            }&#10;            &#10;            ActionType.OPEN_SETTINGS -&gt; {&#10;                Log.d(TAG, &quot;Opening app settings&quot;)&#10;                openAppLocationSettings(context)&#10;            }&#10;            &#10;            ActionType.ENABLE_LOCATION_SERVICES -&gt; {&#10;                Log.d(TAG, &quot;Opening location services settings&quot;)&#10;                openLocationServicesSettings(context)&#10;            }&#10;            &#10;            ActionType.NONE -&gt; {&#10;                Log.d(TAG, &quot;No action needed&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Setup geofencing dengan koordinat yang diberikan&#10;     */&#10;    fun setupGeofenceWithStatus(&#10;        context: Context,&#10;        locationId: String,&#10;        latitude: Double,&#10;        longitude: Double,&#10;        radius: Float = 100f&#10;    ): GeofenceSetupStatus {&#10;        val status = checkGeofenceSetup(context)&#10;        &#10;        if (status.isReady) {&#10;            Log.i(TAG, &quot;Setting up geofence for location: $locationId&quot;)&#10;            geofenceManager.addGeofence(locationId, latitude, longitude, radius)&#10;            &#10;            return status.copy(&#10;                message = status.message + &quot;\n\n Geofence telah diaktifkan untuk lokasi ini.&quot;&#10;            )&#10;        } else {&#10;            Log.w(TAG, &quot;Cannot setup geofence - prerequisites not met&quot;)&#10;            return status&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get detailed status untuk debugging&#10;     */&#10;    fun getDetailedStatus(context: Context): String {&#10;        val status = checkGeofenceSetup(context)&#10;        val permissionStatus = LocationPermissionHelper.getPermissionStatusSummary(context)&#10;        &#10;        return buildString {&#10;            appendLine(&quot;=== GEOFENCE SETUP STATUS ===&quot;)&#10;            appendLine(&quot;Ready: ${if (status.isReady) &quot;&quot; else &quot;&quot;}&quot;)&#10;            appendLine(&quot;Mode: ${status.mode}&quot;)&#10;            appendLine(&quot;Message: ${status.message}&quot;)&#10;            appendLine(&quot;Needs Action: ${status.needsAction}&quot;)&#10;            if (status.needsAction) {&#10;                appendLine(&quot;Action Required: ${status.actionType}&quot;)&#10;            }&#10;            appendLine()&#10;            appendLine(permissionStatus)&#10;            appendLine(&quot;Status Message: ${geofenceManager.getStatusMessage()}&quot;)&#10;            appendLine(&quot;=============================&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Open app-specific location settings&#10;     */&#10;    private fun openAppLocationSettings(context: Context) {&#10;        try {&#10;            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {&#10;                data = Uri.fromParts(&quot;package&quot;, context.packageName, null)&#10;                flags = Intent.FLAG_ACTIVITY_NEW_TASK&#10;            }&#10;            context.startActivity(intent)&#10;            Log.d(TAG, &quot;Opened app location settings&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to open app settings&quot;, e)&#10;            // Fallback&#10;            openLocationServicesSettings(context)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Open general location services settings&#10;     */&#10;    private fun openLocationServicesSettings(context: Context) {&#10;        try {&#10;            val intent = Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS).apply {&#10;                flags = Intent.FLAG_ACTIVITY_NEW_TASK&#10;            }&#10;            context.startActivity(intent)&#10;            Log.d(TAG, &quot;Opened location services settings&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to open location settings&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test geofencing setup dengan koordinat dummy&#10;     */&#10;    fun testGeofenceSetup(context: Context) {&#10;        Log.d(TAG, &quot;=== TESTING GEOFENCE SETUP ===&quot;)&#10;        &#10;        val status = checkGeofenceSetup(context)&#10;        Log.d(TAG, &quot;Setup Status: $status&quot;)&#10;        &#10;        if (status.isReady) {&#10;            // Test dengan koordinat Jakarta&#10;            val testResult = setupGeofenceWithStatus(&#10;                context = context,&#10;                locationId = &quot;TEST_JAKARTA_${System.currentTimeMillis()}&quot;,&#10;                latitude = -6.2088,&#10;                longitude = 106.8456,&#10;                radius = 100f&#10;            )&#10;            Log.d(TAG, &quot;Test Result: $testResult&quot;)&#10;        } else {&#10;            Log.w(TAG, &quot;Cannot test - setup not ready: ${status.message}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceSetupViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/presentation/geofencing/GeofenceSetupViewModel.kt" />
              <option name="updatedContent" value="package com.example.infinite_track.presentation.geofencing&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel untuk menangani setup dan konfigurasi Geofencing&#10; * Mengintegrasikan dengan GeofenceSetupService untuk logika bisnis&#10; */&#10;@HiltViewModel&#10;class GeofenceSetupViewModel @Inject constructor(&#10;    private val geofenceSetupService: GeofenceSetupService&#10;) : ViewModel() {&#10;&#10;    private val _setupStatus = MutableStateFlow&lt;GeofenceSetupService.GeofenceSetupStatus?&gt;(null)&#10;    val setupStatus: StateFlow&lt;GeofenceSetupService.GeofenceSetupStatus?&gt; = _setupStatus.asStateFlow()&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _detailedStatus = MutableStateFlow(&quot;&quot;)&#10;    val detailedStatus: StateFlow&lt;String&gt; = _detailedStatus.asStateFlow()&#10;&#10;    /**&#10;     * Check geofencing setup status&#10;     */&#10;    fun checkSetup(context: Context) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            &#10;            try {&#10;                val status = geofenceSetupService.checkGeofenceSetup(context)&#10;                _setupStatus.value = status&#10;                &#10;                // Update detailed status for debugging&#10;                val detailed = geofenceSetupService.getDetailedStatus(context)&#10;                _detailedStatus.value = detailed&#10;                &#10;            } catch (e: Exception) {&#10;                _setupStatus.value = GeofenceSetupService.GeofenceSetupStatus(&#10;                    isReady = false,&#10;                    mode = GeofenceManager.GeofenceOperationMode.DISABLED,&#10;                    message = &quot; Error checking setup: ${e.message}&quot;,&#10;                    needsAction = true,&#10;                    actionType = GeofenceSetupService.ActionType.OPEN_SETTINGS&#10;                )&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle setup action&#10;     */&#10;    fun handleAction(context: Context, actionType: GeofenceSetupService.ActionType) {&#10;        viewModelScope.launch {&#10;            geofenceSetupService.handleSetupAction(context, actionType)&#10;            &#10;            // Re-check status after action&#10;            kotlinx.coroutines.delay(1000) // Give some time for user to grant permission&#10;            checkSetup(context)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Setup geofence for specific location&#10;     */&#10;    fun setupGeofence(&#10;        context: Context,&#10;        locationId: String,&#10;        latitude: Double,&#10;        longitude: Double,&#10;        radius: Float = 100f&#10;    ) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            &#10;            try {&#10;                val result = geofenceSetupService.setupGeofenceWithStatus(&#10;                    context = context,&#10;                    locationId = locationId,&#10;                    latitude = latitude,&#10;                    longitude = longitude,&#10;                    radius = radius&#10;                )&#10;                _setupStatus.value = result&#10;                &#10;            } catch (e: Exception) {&#10;                _setupStatus.value = GeofenceSetupService.GeofenceSetupStatus(&#10;                    isReady = false,&#10;                    mode = GeofenceManager.GeofenceOperationMode.DISABLED,&#10;                    message = &quot; Error setting up geofence: ${e.message}&quot;,&#10;                    needsAction = true,&#10;                    actionType = GeofenceSetupService.ActionType.OPEN_SETTINGS&#10;                )&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test geofencing setup&#10;     */&#10;    fun testGeofencing(context: Context) {&#10;        viewModelScope.launch {&#10;            geofenceSetupService.testGeofenceSetup(context)&#10;            checkSetup(context)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh setup status&#10;     */&#10;    fun refresh(context: Context) {&#10;        checkSetup(context)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/utils/GeofenceDebugHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/utils/GeofenceDebugHelper.kt" />
              <option name="updatedContent" value="package com.example.infinite_track.utils&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.example.infinite_track.presentation.geofencing.GeofenceManager&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Utility class untuk debugging dan testing Geofencing&#10; * Membantu troubleshoot masalah konfigurasi geofence&#10; */&#10;@Singleton&#10;class GeofenceDebugHelper @Inject constructor(&#10;    private val geofenceManager: GeofenceManager&#10;) {&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;GeofenceDebug&quot;&#10;    }&#10;&#10;    /**&#10;     * Comprehensive diagnostic check untuk Geofencing&#10;     */&#10;    fun runGeofenceDiagnostic(context: Context) {&#10;        Log.d(TAG, &quot;=== GEOFENCE DIAGNOSTIC STARTED ===&quot;)&#10;        &#10;        // 1. Check permissions&#10;        val permissionStatus = LocationPermissionHelper.getPermissionStatusSummary(context)&#10;        Log.d(TAG, permissionStatus)&#10;        &#10;        // 2. Check GeofenceManager status&#10;        val allPermissions = geofenceManager.checkAllPermissions()&#10;        Log.d(TAG, &quot;GeofenceManager Permission Check: ${if (allPermissions) &quot; PASS&quot; else &quot; FAIL&quot;}&quot;)&#10;        &#10;        // 3. Device info&#10;        Log.d(TAG, &quot;Device SDK: ${android.os.Build.VERSION.SDK_INT}&quot;)&#10;        Log.d(TAG, &quot;Device Model: ${android.os.Build.MODEL}&quot;)&#10;        Log.d(TAG, &quot;Device Manufacturer: ${android.os.Build.MANUFACTURER}&quot;)&#10;        &#10;        // 4. Google Play Services availability&#10;        try {&#10;            val gmsAvailable = com.google.android.gms.common.ConnectionResult.SUCCESS == &#10;                com.google.android.gms.common.GoogleApiAvailability.getInstance()&#10;                    .isGooglePlayServicesAvailable(context)&#10;            Log.d(TAG, &quot;Google Play Services: ${if (gmsAvailable) &quot; Available&quot; else &quot; Not Available&quot;}&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error checking Google Play Services&quot;, e)&#10;        }&#10;        &#10;        Log.d(TAG, &quot;=== GEOFENCE DIAGNOSTIC COMPLETED ===&quot;)&#10;    }&#10;&#10;    /**&#10;     * Test geofence dengan koordinat dummy&#10;     */&#10;    fun testGeofenceCreation(latitude: Double = -6.2088, longitude: Double = 106.8456, radius: Float = 100f) {&#10;        Log.d(TAG, &quot;=== TESTING GEOFENCE CREATION ===&quot;)&#10;        Log.d(TAG, &quot;Test Location: Jakarta ($latitude, $longitude)&quot;)&#10;        Log.d(TAG, &quot;Test Radius: ${radius}m&quot;)&#10;        &#10;        // Create test geofence&#10;        geofenceManager.addGeofence(&#10;            id = &quot;TEST_GEOFENCE_${System.currentTimeMillis()}&quot;,&#10;            latitude = latitude,&#10;            longitude = longitude,&#10;            radius = radius&#10;        )&#10;        &#10;        Log.d(TAG, &quot;=== GEOFENCE TEST INITIATED ===&quot;)&#10;        Log.d(TAG, &quot;Check logs above for success/failure messages&quot;)&#10;    }&#10;&#10;    /**&#10;     * Remove all test geofences&#10;     */&#10;    fun cleanupTestGeofences() {&#10;        Log.d(TAG, &quot;Cleaning up all geofences...&quot;)&#10;        geofenceManager.removeAllGeofences()&#10;    }&#10;&#10;    /**&#10;     * Validate geofence parameters&#10;     */&#10;    fun validateGeofenceParams(id: String, latitude: Double, longitude: Double, radius: Float): Boolean {&#10;        val issues = mutableListOf&lt;String&gt;()&#10;        &#10;        // Validate ID&#10;        if (id.isBlank()) {&#10;            issues.add(&quot;Geofence ID cannot be empty&quot;)&#10;        }&#10;        &#10;        // Validate coordinates&#10;        if (latitude &lt; -90 || latitude &gt; 90) {&#10;            issues.add(&quot;Invalid latitude: $latitude (must be between -90 and 90)&quot;)&#10;        }&#10;        &#10;        if (longitude &lt; -180 || longitude &gt; 180) {&#10;            issues.add(&quot;Invalid longitude: $longitude (must be between -180 and 180)&quot;)&#10;        }&#10;        &#10;        // Validate radius&#10;        if (radius &lt; 100) {&#10;            issues.add(&quot;Radius too small: ${radius}m (minimum 100m recommended)&quot;)&#10;        }&#10;        &#10;        if (radius &gt; 10000) {&#10;            issues.add(&quot;Radius too large: ${radius}m (maximum 10km recommended)&quot;)&#10;        }&#10;        &#10;        // Log results&#10;        if (issues.isEmpty()) {&#10;            Log.d(TAG, &quot; Geofence parameters are valid&quot;)&#10;            return true&#10;        } else {&#10;            Log.e(TAG, &quot; Geofence parameter validation failed:&quot;)&#10;            issues.forEach { issue -&gt;&#10;                Log.e(TAG, &quot;  - $issue&quot;)&#10;            }&#10;            return false&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/utils/LocationPermissionHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/utils/LocationPermissionHelper.kt" />
              <option name="updatedContent" value="package com.example.infinite_track.utils&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.provider.Settings&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;&#10;/**&#10; * Helper class untuk menangani permission request untuk Geofencing&#10; * Mengikuti best practices Android untuk location permissions&#10; */&#10;object LocationPermissionHelper {&#10;&#10;    const val PERMISSION_REQUEST_FOREGROUND_LOCATION = 1001&#10;    const val PERMISSION_REQUEST_BACKGROUND_LOCATION = 1002&#10;&#10;    /**&#10;     * Array izin lokasi foreground yang diperlukan&#10;     */&#10;    val FOREGROUND_LOCATION_PERMISSIONS = arrayOf(&#10;        Manifest.permission.ACCESS_FINE_LOCATION,&#10;        Manifest.permission.ACCESS_COARSE_LOCATION&#10;    )&#10;&#10;    /**&#10;     * Izin background location (hanya untuk API 29+)&#10;     */&#10;    const val BACKGROUND_LOCATION_PERMISSION = Manifest.permission.ACCESS_BACKGROUND_LOCATION&#10;&#10;    /**&#10;     * Cek apakah semua izin foreground location sudah diberikan&#10;     */&#10;    fun hasForegroundLocationPermissions(context: Context): Boolean {&#10;        return FOREGROUND_LOCATION_PERMISSIONS.any { permission -&gt;&#10;            ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cek apakah izin background location sudah diberikan&#10;     */&#10;    fun hasBackgroundLocationPermission(context: Context): Boolean {&#10;        return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            ContextCompat.checkSelfPermission(&#10;                context,&#10;                BACKGROUND_LOCATION_PERMISSION&#10;            ) == PackageManager.PERMISSION_GRANTED&#10;        } else {&#10;            // Tidak diperlukan untuk API &lt; 29&#10;            true&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cek apakah semua izin yang diperlukan untuk Geofencing sudah diberikan&#10;     */&#10;    fun hasAllGeofencePermissions(context: Context): Boolean {&#10;        return hasForegroundLocationPermissions(context) &amp;&amp; hasBackgroundLocationPermission(context)&#10;    }&#10;&#10;    /**&#10;     * Request foreground location permissions&#10;     */&#10;    fun requestForegroundLocationPermissions(&#10;        fragment: Fragment,&#10;        launcher: ActivityResultLauncher&lt;Array&lt;String&gt;&gt;&#10;    ) {&#10;        launcher.launch(FOREGROUND_LOCATION_PERMISSIONS)&#10;    }&#10;&#10;    /**&#10;     * Request background location permission (hanya setelah foreground permission diberikan)&#10;     */&#10;    fun requestBackgroundLocationPermission(&#10;        fragment: Fragment,&#10;        launcher: ActivityResultLauncher&lt;String&gt;&#10;    ) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            launcher.launch(BACKGROUND_LOCATION_PERMISSION)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Buka pengaturan aplikasi untuk manual permission setting&#10;     */&#10;    fun openAppSettings(context: Context) {&#10;        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {&#10;            data = Uri.fromParts(&quot;package&quot;, context.packageName, null)&#10;        }&#10;        context.startActivity(intent)&#10;    }&#10;&#10;    /**&#10;     * Get user-friendly explanation untuk permission request&#10;     */&#10;    fun getPermissionExplanation(permission: String): String {&#10;        return when (permission) {&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION -&gt; {&#10;                &quot;Aplikasi memerlukan izin lokasi untuk fitur presensi berbasis geofence. &quot; +&#10;                        &quot;Ini memungkinkan sistem mendeteksi ketika Anda masuk/keluar area kerja.&quot;&#10;            }&#10;            Manifest.permission.ACCESS_BACKGROUND_LOCATION -&gt; {&#10;                &quot;Untuk Android 10+, aplikasi memerlukan izin 'Allow all the time' agar geofence &quot; +&#10;                        &quot;tetap berfungsi saat aplikasi tidak aktif. Pilih 'Allow all the time' di pengaturan lokasi.&quot;&#10;            }&#10;            else -&gt; &quot;Izin ini diperlukan untuk fungsi aplikasi yang optimal.&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get permission status summary untuk debugging&#10;     */&#10;    fun getPermissionStatusSummary(context: Context): String {&#10;        val foreground = hasForegroundLocationPermissions(context)&#10;        val background = hasBackgroundLocationPermission(context)&#10;        val apiLevel = Build.VERSION.SDK_INT&#10;        &#10;        return buildString {&#10;            appendLine(&quot;=== PERMISSION STATUS SUMMARY ===&quot;)&#10;            appendLine(&quot;API Level: $apiLevel&quot;)&#10;            appendLine(&quot;Foreground Location: ${if (foreground) &quot; GRANTED&quot; else &quot; DENIED&quot;}&quot;)&#10;            &#10;            if (apiLevel &gt;= Build.VERSION_CODES.Q) {&#10;                appendLine(&quot;Background Location: ${if (background) &quot; GRANTED&quot; else &quot; DENIED&quot;}&quot;)&#10;                appendLine(&quot;Note: Background permission required for API 29+&quot;)&#10;            } else {&#10;                appendLine(&quot;Background Location:  NOT REQUIRED (API &lt; 29)&quot;)&#10;            }&#10;            &#10;            appendLine(&quot;Geofence Ready: ${if (hasAllGeofencePermissions(context)) &quot; YES&quot; else &quot; NO&quot;}&quot;)&#10;            appendLine(&quot;================================&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/utils/PermissionDialogHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/infinite_track/utils/PermissionDialogHelper.kt" />
              <option name="updatedContent" value="package com.example.infinite_track.utils&#10;&#10;import android.app.AlertDialog&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.provider.Settings&#10;import android.util.Log&#10;&#10;/**&#10; * Helper untuk menangani permission dialog dan guidance untuk user&#10; * Khusus untuk Android 10+ background location permission&#10; */&#10;object PermissionDialogHelper {&#10;    &#10;    private const val TAG = &quot;PermissionDialog&quot;&#10;&#10;    /**&#10;     * Show explanation dialog for background location permission&#10;     */&#10;    fun showBackgroundLocationPermissionDialog(&#10;        context: Context,&#10;        onPositiveClick: () -&gt; Unit,&#10;        onNegativeClick: () -&gt; Unit = {}&#10;    ) {&#10;        val dialog = AlertDialog.Builder(context)&#10;            .setTitle(&quot;Izin Lokasi Latar Belakang Diperlukan&quot;)&#10;            .setMessage(getBackgroundLocationExplanation())&#10;            .setPositiveButton(&quot;Buka Pengaturan&quot;) { _, _ -&gt;&#10;                onPositiveClick()&#10;                openLocationSettings(context)&#10;            }&#10;            .setNegativeButton(&quot;Nanti Saja&quot;) { dialog, _ -&gt;&#10;                onNegativeClick()&#10;                dialog.dismiss()&#10;            }&#10;            .setCancelable(false)&#10;            .create()&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    /**&#10;     * Show step-by-step guide for granting background location&#10;     */&#10;    fun showBackgroundLocationGuide(context: Context) {&#10;        val steps = getLocationPermissionSteps()&#10;        &#10;        AlertDialog.Builder(context)&#10;            .setTitle(&quot;Cara Memberikan Izin Lokasi&quot;)&#10;            .setMessage(steps)&#10;            .setPositiveButton(&quot;Buka Pengaturan&quot;) { _, _ -&gt;&#10;                openLocationSettings(context)&#10;            }&#10;            .setNegativeButton(&quot;Tutup&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;            }&#10;            .create()&#10;            .show()&#10;    }&#10;&#10;    /**&#10;     * Open app-specific location settings&#10;     */&#10;    private fun openLocationSettings(context: Context) {&#10;        try {&#10;            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {&#10;                data = Uri.fromParts(&quot;package&quot;, context.packageName, null)&#10;            }&#10;            context.startActivity(intent)&#10;            Log.d(TAG, &quot;Opened app settings for location permission&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to open app settings&quot;, e)&#10;            // Fallback to general location settings&#10;            openGeneralLocationSettings(context)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Open general location settings as fallback&#10;     */&#10;    private fun openGeneralLocationSettings(context: Context) {&#10;        try {&#10;            val intent = Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS)&#10;            context.startActivity(intent)&#10;            Log.d(TAG, &quot;Opened general location settings&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to open location settings&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get explanation text for background location permission&#10;     */&#10;    private fun getBackgroundLocationExplanation(): String {&#10;        return &quot;&quot;&quot;&#10;            Aplikasi Infinite Track memerlukan akses lokasi latar belakang untuk:&#10;            &#10;             Presensi otomatis saat masuk/keluar area kerja&#10;             Tracking Work From Anywhere (WFA) yang akurat&#10;             Data analytics untuk evaluasi kinerja&#10;            &#10;            Untuk Android ${Build.VERSION.SDK_INT}, pilih &quot;Allow all the time&quot; di pengaturan lokasi.&#10;            &#10;            Data lokasi hanya digunakan untuk presensi dan tidak dibagikan ke pihak ketiga.&#10;        &quot;&quot;&quot;.trimIndent()&#10;    }&#10;&#10;    /**&#10;     * Get step-by-step instructions for different Android versions&#10;     */&#10;    private fun getLocationPermissionSteps(): String {&#10;        return when {&#10;            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R -&gt; { // Android 11+&#10;                &quot;&quot;&quot;&#10;                Langkah untuk Android 11+ (API ${Build.VERSION.SDK_INT}):&#10;                &#10;                1 Buka pengaturan aplikasi Infinite Track&#10;                2 Tap &quot;Permissions&quot; atau &quot;Izin&quot;&#10;                3 Tap &quot;Location&quot; atau &quot;Lokasi&quot;&#10;                4 Pilih &quot;Allow all the time&quot;&#10;                5 Konfirmasi dengan tap &quot;Allow&quot;&#10;                &#10;                 Penting: Jangan pilih &quot;Allow only while using the app&quot;&#10;                &quot;&quot;&quot;.trimIndent()&#10;            }&#10;            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q -&gt; { // Android 10&#10;                &quot;&quot;&quot;&#10;                Langkah untuk Android 10 (API ${Build.VERSION.SDK_INT}):&#10;                &#10;                1 Buka pengaturan aplikasi Infinite Track&#10;                2 Tap &quot;Permissions&quot;&#10;                3 Tap &quot;Location&quot;&#10;                4 Pilih &quot;Allow all the time&quot;&#10;                &#10;                 Tips: Jika tidak ada opsi &quot;Allow all the time&quot;, &#10;                aktifkan dulu &quot;Allow while using app&quot;, lalu ulangi langkah di atas.&#10;                &quot;&quot;&quot;.trimIndent()&#10;            }&#10;            else -&gt; {&#10;                &quot;&quot;&quot;&#10;                Langkah untuk Android 9 dan sebelumnya:&#10;                &#10;                1 Buka pengaturan aplikasi Infinite Track&#10;                2 Tap &quot;Permissions&quot;&#10;                3 Pastikan &quot;Location&quot; diaktifkan&#10;                &#10;                 Untuk versi Android Anda, tidak perlu pengaturan tambahan.&#10;                &quot;&quot;&quot;.trimIndent()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if user should be shown the permission rationale&#10;     */&#10;    fun shouldShowPermissionRationale(context: Context): Boolean {&#10;        // Always show rationale for background location as it's critical&#10;        return !LocationPermissionHelper.hasBackgroundLocationPermission(context) &amp;&amp; &#10;               Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>